export const description =
  "Reference for Nitric's Node.js library - Register a handler for connections, disconnections, or messages for the websocket."

# Node.js - Websocket.On()

Register a handler for connections, disconnections, or messages for the websocket.

```javascript
import { websocket } from '@nitric/sdk'

const socket = websocket('socket')

socket.on('connect', async (ctx) => {
  // handle connections
})

socket.on('disconnect', async (ctx) => {
  // handle disconnections
})

socket.on('message', async (ctx) => {
  // handle messages
})
```

## Parameters

<Properties>
  <Property name="eventType" required type="string">
    The type of websocket event to listen for. Can be `connect`,
    `disconnect`, or `message`.
  </Property>
  <Property name="middleware" required type="WebsocketMiddleware<T>">
    The middleware function(s) to use as handlers for the Websocket events.
  </Property>
</Properties>

## Examples

### Register a handler for message events

```javascript
socket.on('message', async (ctx) => {
  // handle messages
  console.log(`new message from ${ctx.req.connectionId}: ${ctx.req.data}`);
})
```

### Manage Websocket connections

Websocket connections need to be managed. This can be done using any persistent datastore you like. One approach is to use a Nitric collection.

```javascript
import { websocket, collection } from '@nitric/sdk'

const socket = websocket('socket')
const connections = collection('connections').for(
  'reading',
  'writing',
  'deleting'
)

socket.on('connect', async (ctx) => {
  await connections.doc(ctx.req.connectionId).set({
    // store any metadata related to the connection here
    connectionId: ctx.req.connectionId,
  })
})

socket.on('disconnect', async (ctx) => {
  await connections.doc(ctx.req.connectionId).delete()
})

```
