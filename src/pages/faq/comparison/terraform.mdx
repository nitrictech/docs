export const description = 'Comparison to Terraform'

# Terraform vs. Nitric

> NOTE: Nitric is not designed to replace IaC tools like Terraform, but instead introduces a method of bringing developer self service for infrastructure directly into the developer application (Nitric's default deployment engines are built with Pulumi).
> Nitric can be augmented through use of tools like Pulumi and even be fully customized using such tools see [Custom Providers]() for more details

Nitric is a framework designed to aid developers in building full cloud applications, including declaring their infrastructure and application code in one place. Terraform is an Infrastructure as Code tool that enables explicit definition of infrastructure using HCL (or programming languages using tf-cdk). The main differences between these are:

1. Nitric is cloud-agnostic, code that is written using nitric constructs can be deployed to any cloud. Terraform supports many clouds, infrastructure declarations are explicitly defined for the provider that a resource is provided by.

1. Nitric defines not only the infrastructure but how it is interacted with at runtime, so infrastructure can be automatically inferred from application code to ensure best practice deployments and least privilege security.

1. Nitric provides tools for locally simulating a cloud environment (using the nitric CLI), to allow application to be tested locally. Pulumi programs can be unit tested but applications written to be deployed will need a separate solution for local development such as LocalStack.

# Side by Side

To showcase the power of the abstraction provided by nitric here is a showcase of a nitric program with an equivalent Terraform configuration with application code.

<CodeGroup compare>

```javascript {{title: 'Nitric', label: 'handle.ts' }}
import * as nitric from '@nitric/sdk'

const bucket = nitric.bucket('my-bucket').for('reading', 'writing')

bucket.on('create', '*', async (ctx) => {
  console.log(ctx.file.key, 'was created')
})
```

```hcl {{title: 'Terraform', label: 'main.tf'}}
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 3.0"
    }
  }
}

provider "aws" {
  region = "us-west-2"
}

locals {
  lambda_function_name = "upload_hello_txt_lambda"
}

resource "aws_s3_bucket" "this" {
  bucket = "my-s3-bucket"
  acl    = "private"
}

data "archive_file" "lambda_zip" {
  type        = "zip"
  source_file = "index.js"
  output_path = "${path.module}/lambda.zip"
}

resource "aws_lambda_function" "this" {
  function_name = local.lambda_function_name
  role          = aws_iam_role.lambda_role.arn
  handler       = "index.handler"
  runtime       = "nodejs14.x"
  filename      = data.archive_file.lambda_zip.output_path
  timeout       = 10

  environment {
    variables = {
      BUCKET_NAME = aws_s3_bucket.this.bucket
    }
  }
}

resource "aws_iam_role" "lambda_role" {
  name = "lambda_role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "lambda_policy" {
  name = "lambda_policy"
  role = aws_iam_role.lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Effect   = "Allow"
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Action = [
          "s3:PutObject"
        ]
        Effect   = "Allow"
        Resource = "${aws_s3_bucket.this.arn}/*"
      }
    ]
  })
}

output "bucket_name" {
  value = aws_s3_bucket.this.bucket
}

output "lambda_function_name" {
  value = aws_lambda_function.this.function_name
}
```

```javascript {{title: 'Terraform', label: 'src/index.js'}}
const AWS = require('aws-sdk')

exports.handler = async (event) => {
  const {
    s3: { object },
  } = event
  console.log(object.key, 'was created')
}
```

</CodeGroup>

> In the pulumi example we get control over absolutely every facet of our infrastructure which is great, but for the majority of use cases a repeatable pattern of deployment is enough and scales much better than applying fine grained configuration every time we need to define a new deployment (with Pulumi this would typically be done by sharing infrastructure as libraries e.g. Pulumi Crosswalks).

The below table contains the main differences that you can see in the code examples, and also some that cannot fit in such a small app, but we still would like you to know about :)

| Feature              | Nitric                                                                     | Terraform                                                |
| -------------------- | -------------------------------------------------------------------------- | -------------------------------------------------------- |
| Language             | Your choice                                                                | HCL                                                      |
| Lines of code        | 7                                                                          | 69                                                       |
| Cloud Infrasutrcture | Inferred                                                                   | Explicit                                                 |
| Extensibility        | Custom providers                                                           | Custom/dynamic providers                                 |
| Local Simulation     | Built-in to CLI                                                            | N/A                                                      |
| Cross-cloud support  | Same code compiles to different clouds                                     | No (need to write different config for different clouds) |
| Provisioning engine  | Custom providers can be written with any IaC tech (e.g. Terraform/AWS CDK) | Proprietary                                              |
| Testing              | Same tests run on local simulator and cloud, without mocks                 | Need mocks for local testing                             |
