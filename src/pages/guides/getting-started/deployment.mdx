export const description = 'How to deploy Nitric applications'

# Deployment

## Managed Nitric with Deploy

[Nitric Deploy](https://deploy.nitric.io) is the fastest way to deploy your Nitric application with no configuration.

When managing your application with Nitric Deploy, the platform detects the presence of nitric and runs `nitric up` to the cloud you've set up in your Nitric Deploy environment and fully manages your deployment including:

- Integrate with GitHub to connect your repositories
- Build Nitric Framework applications
- Clone a sample project to see how it works
- Configure multiple Stacks for each project (e.g. Production & Staging)
- Connect & deploy your apps to your own AWS account

With more on the way...

## Self-Hosting

You can self-host nitric deployments in your own CI/CD as well using the Nitric CLI.

### Configuring Pulumi

The current providers in nitric for AWS, GCP and Azure all use [Pulumi](https://pulumi.com) under the hood for their deployments, so Pulumi will need to be configured to persist your stack state and to run the deployment to the cloud of your choice.

#### Configuring cloud credentials

You will need to configure your cloud credentials for your CI/CD pipeline to allow nitric to create resources in your cloud account, instructions on doing this can be found in our provider documentation for each of the clouds: [AWS](/reference/providers/aws), [GCP](/reference/providers/gcp) and [Azure](/reference/providers/azure)

#### Configuring State Backend

For nitric to maintain the state of your deployment between runs you will also need to configure a backend for Pulumi to store its stack state. For this, you can use either [Pulumi's managed service](https://www.pulumi.com/intro/concepts/state/#logging-into-the-pulumi-service-backend), or you could use one of the other state [backends](https://www.pulumi.com/intro/concepts/state/#logging-into-a-self-managed-backend) they provide support for.

## Configuring Deployment

When deploying the application, you can add extra configuration for specific functions or a global function. This configuration is individualized for each stack file. Below is an example of config added to an AWS stack to augment the memory, timeout, and telemetry sampling percentage.

```yaml
# nitric-aws-deployment.yaml
name: project
provider: nitric/aws@0.24.0
region: us-east-1
telemetry: 10
config:
  default:
    lambda:
      memory: 1024
  memory-optimized:
    lambda:
      memory: 4096
```

And pointing the handlers to each different config happens in the project file:

```yaml
# nitric.yaml
name: my-project
handlers:
  - match: functions/*.ts
    type: default
  - match: custom/*.ts
    type: memory-optimized
```

You can point config to all functions, or to a specific function. Either by using the `default` key or the function type i.e. `memory-optimized`. The following configurations can be made:

- `memory`: The memory of the compute instance in MB. Defaults to 512.
- `timeout`: The max running time of the function in seconds. Defaults to 15.
- `telemetry`: The percentage of requests to be sampled for tracing. Defaults to 0%.

For AWS, [provisioned concurrency](https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html) can also be added:

- `provisioned-concurrency`: The number of lambda instances that should remain warm for immediate invocation.
