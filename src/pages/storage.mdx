export const description = 'Working with files and storage in Nitric'

# Storage

Nitric provides storage support for securely storing and retrieving large files in the cloud.

Here is a quick introduction on Nitric storage if you'd prefer to learn via video.

<div>
  <div className="video-container">
    <iframe
      src="https://www.youtube-nocookie.com/embed/5PSyecQ80zg"
      title="Store Petabytes with Cloud Buckets"
      frameBorder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowFullScreen
    />
  </div>
</div>

## Definitions

### Files

Files refer to binary files, such as documents (.doc, .pdf), images (.gif, .jpg), or videos (.mp4, .mkv). It is common for these files to be referred to as BLOBs, which stands for Binary Large Objects.Storing these types of files in buckets, as opposed to other data persistence systems like SQL or document databases, can improve performance.

### Buckets

Buckets serve as isolated repositories for files. To illustrate, think of a bucket as a partition on a traditional hard drive system. Creating separate buckets becomes necessary when storing files for distinct purposes or with varying access control requirements. For instance, you might establish an "uploads" bucket to handle user file uploads or a "profiles" bucket specifically designed for storing user profile images.

### Folders

Most cloud object/blob storage services function as key-value systems, where the keys represent filenames and the values contain the actual file data. By incorporating paths within filenames, you can organize files within a bucket, similar to how folders are utilized in local storage. For example, if you have a file named `profile.png`, you can store it in the folder `images/default` by specifying the complete file path when reading or writing the file, e.g., `images/default/profile.png`.

## Create Buckets

Nitric enables you to define named buckets with customizable permissions. When defining a bucket, you can specify permissions for reading, writing, and deleting files within the bucket. In the example below, we declare a bucket named `profiles` and indicate that our function requires access to read, write, and delete files within that bucket:

<CodeGroup>

```javascript
import { bucket } from '@nitric/sdk'

const profiles = bucket('profiles').for('reading', 'writing', 'deleting')
```

```python
from nitric.resources import bucket
from nitric.application import Nitric

profiles = bucket('profiles').allow('reading', 'writing', 'deleting')

Nitric.run()
```

```go
import (
  "fmt"

  "github.com/nitrictech/go-sdk/nitric"
)

func main() {
  profiles, err := nitric.NewBucket("profiles").With(resources.BucketWriting, resources.BucketReading, resources.BucketDeleting)
  if err != nil {
    return
  }

  if err := nitric.Run(); err != nil {
    fmt.Println(err)
  }
}
```

```csharp
using Nitric.Sdk;
using Nitric.Sdk.Resources;

var profiles = Nitric.Bucket("profiles").With(BucketPermission.Writing, BucketPermission.Reading, BucketPermission.Deleting);

Nitric.Run();
```

```java
import io.nitric.Nitric;
import io.nitric.resources.BucketPermission;

public class Application {
	public static void main(String[] args) {
		var profiles = Nitric.INSTANCE.bucket("profiles").with(BucketPermission.Write);

		Nitric.INSTANCE.run();
	}
}
```

```kotlin
import io.nitric.Nitric
import io.nitric.resources.BucketPermission

fun main() {
	val profiles = Nitric.bucket("profiles").with(BucketPermission.Write)

	Nitric.INSTANCE.run()
}
```

</CodeGroup>

## File references

You can obtain a reference to a `File` within a bucket by either using its name or by listing all the files present in the bucket. Once you have a reference to a file, you can perform various operations on it, including retrieving its contents, writing new content to it, or deleting it.

To get a reference to a specific file in a bucket, use the `file()` method on the bucket reference. This returns a `File` reference so other operations can be performed on the file.

<Note>
  No network calls are made when you get a file reference using `file()`
</Note>

<CodeGroup>

```javascript
import { bucket } from '@nitric/sdk'

const profiles = bucket('profiles').for('reading')

const profilePicture = profiles.file('users/bruce-wayne/profile.png')
```

```python
from nitric.resources import bucket
from nitric.application import Nitric

profiles = bucket("profiles").allow("reading")

profile_picture = profiles.file("users/bruce-wayne/profile.png")

Nitric.run()
```

```go
import (
  "fmt"

  "github.com/nitrictech/go-sdk/nitric"
)

func main() {
  profiles, err := nitric.NewBucket("profiles").With(resources.BucketReading)
  if err != nil {
    return
  }

  profilePicture := profiles.File("users/bruce-wayne/profile.png")

  if err := nitric.Run(); err != nil {
    fmt.Println(err)
  }
}
```

```csharp
using Nitric.Sdk;
using Nitric.Sdk.Resources;

var profiles = Nitric.Bucket("profiles").With(BucketPermission.Reading);

var profilePicture = profiles.File("users/bruce-wayne/profile.png");

Nitric.Run();
```

```java
import io.nitric.Nitric;
import io.nitric.resources.BucketPermission;

public class Application {
	public static void main(String[] args) {
		var profiles = Nitric.INSTANCE.bucket("profiles").with(BucketPermission.Read);

		var profilePicture = profiles.file("users/bruce-wayne/profile.png");

		Nitric.INSTANCE.run();
	}
}
```

```kotlin
import io.nitric.Nitric
import io.nitric.resources.BucketPermission

fun main() {
	val profiles = Nitric.bucket("profiles").with(BucketPermission.Read)

	val profilePicture = profiles.file("users/bruce-wayne/profile.png")

	Nitric.run()
}
```

</CodeGroup>

To list all files in a bucket, use the `files()` method on the bucket reference. The function must have `read` permissions to list the files within a bucket.

<Note>A network call is made when you list files using `files()`</Note>

<CodeGroup>

```typescript
import { bucket } from '@nitric/sdk'

const profiles = bucket('profiles').for('reading')

const files = await profiles.files()

files.forEach((file) => {
  console.log(file.name)
})
```

```python
from nitric.resources import bucket
from nitric.application import Nitric

profiles = bucket("profiles").allow("reading")

files = await profiles.files()

for file in files:
  print(file.name)

Nitric.run()
```

```go
import (
  "context"
  "fmt"

  "github.com/nitrictech/go-sdk/nitric"
)

func main() {
  profiles, err := nitric.NewBucket("profiles").With(resources.BucketReading)
  if err != nil {
    return
  }

  files, err := profiles.Files(context.TODO())
  if err != nil {
    return
  }

  for _, file := range files {
    fmt.Println(file.Name)
  }

  if err := nitric.Run(); err != nil {
    fmt.Println(err)
  }
}
```

```csharp
using Nitric.Sdk;
using Nitric.Sdk.Resources;

var profiles = Nitric.Bucket("profiles").With(BucketPermission.Reading);

var files = profiles.Files();

files.ForEach(file => {
  Console.WriteLine(file.Name);
});

Nitric.Run();
```

```java
import io.nitric.Nitric;
import io.nitric.resources.BucketPermission;

public class Application {
	public static void main(String[] args) {
		var profiles = Nitric.INSTANCE.bucket("profiles").with(BucketPermission.Read);

		var files = profiles.files();

		files.forEach((file) -> {
			System.out.println(file.getName());
		});

		Nitric.INSTANCE.run();
	}
}
```

```kotlin
import io.nitric.Nitric
import io.nitric.resources.BucketPermission

fun main() {
	val profiles = Nitric.bucket("profiles").with(BucketPermission.Read)

	val files = profiles.files()

	files.forEach { file ->
		println(file.name)
	}

	Nitric.run()
}
```

</CodeGroup>

## Read files

You can read the contents of a file directly from your application code using the `read()` method on a file reference. The contents of the file are returned as a byte array.

<Note>
  If a file with that name does not exist when `read()` is called a `NOT_FOUND`
  error will be thrown.
</Note>

<CodeGroup>

```javascript
import { bucket } from '@nitric/sdk'

const profiles = bucket('profiles').for('reading')

const image = await profiles.file('users/bruce-wayne/profile.png').read()
```

```python
from nitric.resources import bucket
from nitric.application import Nitric

profiles = bucket("profiles").allow("reading")

image = await profile.file("users/bruce-wayne/profile.png").read()

Nitric.run()
```

```go
import (
  "context"
  "fmt"

  "github.com/nitrictech/go-sdk/nitric"
)

func main() {
  profiles, err := nitric.NewBucket("profiles").With(resources.BucketReading)
  if err != nil {
    return
  }

  image, err := profiles.File("users/bruce-wayne/profile.png").Read(context.TODO())
  if err != nil {
    return
  }

  if err := nitric.Run(); err != nil {
    fmt.Println(err)
  }
}
```

```csharp
using Nitric.Sdk;
using Nitric.Sdk.Resources;

var profiles = Nitric.Bucket("profiles").With(BucketPermission.Reading);

var image = profiles.File("users/bruce-wayne/profile.png").Read();

Nitric.Run();
```

```java
import io.nitric.Nitric;
import io.nitric.resources.BucketPermission;

public class Application {
	public static void main(String[] args) {
		var profiles = Nitric.INSTANCE.bucket("profiles").with(BucketPermission.Read);

		var image = profiles.file("users/bruce-wayne/profile.png");

		Nitric.INSTANCE.run();
	}
}
```

```kotlin
import io.nitric.Nitric
import io.nitric.resources.BucketPermission

fun main() {
	val profiles = Nitric.bucket("profiles").with(BucketPermission.Read)

	val image = profiles.file("users/bruce-wayne/profile.png")

	Nitric.run()
}
```

</CodeGroup>

## Write files

You can write the contents of a file directly from your application code using the `write()` method on a file reference. If the file doesn't exist then it will create a new one, if it does exist then it will overwrite the previous data.

<Note>
  Written data cannot exceed 4MB. If you need to upload more than that, consider
  using an [upload url](#signed-urls).
</Note>

<CodeGroup>

```javascript
import { bucket } from '@nitric/sdk'

const profiles = bucket('profiles').for('writing')

const profileImage = 'image data'

await profiles.file('users/bruce-wayne/profile.png').write(profileImage)
```

```python
from nitric.resources import bucket
from nitric.application import Nitric

profiles = bucket("profiles").allow("writing")

profileImage = b"image data"

await profiles.file("users/bruce-wayne/profile.png").write(profileImage)

Nitric.run()
```

```go
import (
  "context"
  "fmt"

  "github.com/nitrictech/go-sdk/nitric"
)

func main() {
  profiles, err := nitric.NewBucket("profiles").With(resources.BucketWriting)
  if err != nil {
    return
  }

  profileImage := []byte("image data")

  err := profiles.File("users/bruce-wayne/profile.png").Write(context.TODO(), profileImage)
  if err != nil {
    return
  }

  if err := nitric.Run(); err != nil {
    fmt.Println(err)
  }
}
```

```csharp
using Nitric.Sdk;
using Nitric.Sdk.Resources;

var profiles = Nitric.Bucket("profiles").With(BucketPermission.Writing);

var profileImage = "image data";

var image = profiles.File("users/bruce-wayne/profile.png").Write(profileImage);

Nitric.Run();
```

```java
import io.nitric.Nitric;
import io.nitric.resources.BucketPermission;

public class Application {
	public static void main(String[] args) {
		var profiles = Nitric.INSTANCE.bucket("profiles").with(BucketPermission.Write);

		profiles.file("users/bruce-wayne/profile.png").write("image data");

		Nitric.INSTANCE.run();
	}
}
```

```kotlin
import io.nitric.Nitric
import io.nitric.resources.BucketPermission

fun main() {
	val profiles = Nitric.bucket("profiles").with(BucketPermission.Write)

	profiles.file("users/bruce-wayne/profile.png").write("image data")

	Nitric.run()
}
```

</CodeGroup>

## Delete files

You can delete a file directly from your application code using the `delete()` method on a file reference.

<CodeGroup>

```javascript
import { bucket } from '@nitric/sdk'

const profiles = bucket('profiles').for('deleting')

await profiles.file('users/bruce-wayne/profile.png').delete()
```

```python
from nitric.resources import bucket
from nitric.application import Nitric

profiles = bucket("profiles").allow("deleting")

await profile.file("users/bruce-wayne/profile.png").delete()

Nitric.run()
```

```go
import (
  "context"
  "fmt"

  "github.com/nitrictech/go-sdk/nitric"
)

func main() {
  profiles, err := nitric.NewBucket("profiles").With(resources.BucketDeleting)
  if err != nil {
    return
  }

  err := profiles.File("users/bruce-wayne/profile.png").Delete(context.TODO())
  if err != nil {
    return
  }

  if err := nitric.Run(); err != nil {
    fmt.Println(err)
  }
}
```

```csharp
using Nitric.Sdk;
using Nitric.Sdk.Resources;

var profiles = Nitric.Bucket("profiles").With(BucketPermission.Deleting);

var image = profiles.File("users/bruce-wayne/profile.png").Delete();

Nitric.Run();
```

```java
import io.nitric.Nitric;
import io.nitric.resources.BucketPermission;

public class Application {
	public static void main(String[] args) {
		var profiles = Nitric.INSTANCE.bucket("profiles").with(BucketPermission.Delete);

		profiles.file("users/bruce-wayne/profile.png").delete();

		Nitric.INSTANCE.run();
	}
}
```

```kotlin
import io.nitric.Nitric
import io.nitric.resources.BucketPermission

fun main() {
	val profiles = Nitric.bucket("profiles").with(BucketPermission.Delete)

	profiles.file("users/bruce-wayne/profile.png").delete()

	Nitric.run()
}
```

</CodeGroup>

## Signed URLs

The signed URL feature enables you to generate temporary URLs for downloading or uploading files. These URLs include authentication information in the query string, allowing users without credentials to access the file. They are particularly useful when you need to share temporary links for file downloads or uploads.

You have the option to customize the expiration time of the URL by specifying a duration in seconds, ranging from 0 to 604,800 (a week). To obtain a download URL, the function needs to have `read` permissions on the bucket. For an upload URL, the function needs to have `write` permissions on the bucket.

<Note>
  It's important to note that anyone with the signed URL can access or modify
  the file. Hence, it's crucial to exercise caution and only share the URL with
  trusted users.
</Note>

<CodeGroup>

```javascript
import { bucket } from '@nitric/sdk'

const profiles = bucket('profiles').for('reading', 'writing')

// Get pre-signed URLs for downloading or uploading
const downloadUrl = await profiles.file('profile.png').getDownloadUrl({
  expiry: 3600, // Expiry defaults to 600 (10 minutes)
})

const uploadUrl = await profiles.file('profile.png').getUploadUrl({
  expiry: 3600, // Expiry defaults to 600 (10 minutes)
})
```

```python
from nitric.resources import bucket
from nitric.application import Nitric

profiles = bucket('profiles').allow('reading', 'writing')

download_url = await profiles.file('profile.png').download_url(3600) # Expiry defaults to 600 (10 minutes)

upload_url = await profiles.file('profile.png').upload_url(3600) # Expiry defaults to 600 (10 minutes)

Nitric.run()
```

```go
import (
  "context"
  "fmt"

  "github.com/nitrictech/go-sdk/nitric"
)

func main() {
  profiles, err := nitric.NewBucket("profiles").With(resources.BucketReading, resources.BucketWriting)
  if err != nil {
    return
  }

  ctx := context.TODO()
  expiry := 3600

  downloadUrl, err := profiles.file("profile.png").DownloadUrl(ctx, expiry) // Expiry defaults to 600 (10 minutes)
  if err != nil {
    return
  }

  uploadUrl, err := profiles.File("profile.png").UploadUrl(ctx, expiry) // Expiry defaults to 600 (10 minutes)
  if err != nil {
    return
  }

  if err := nitric.Run(); err != nil {
    fmt.Println(err)
  }
}
```

```csharp
using Nitric.Sdk;
using Nitric.Sdk.Resources;

var profiles = Nitric.Bucket("profiles").With(BucketPermission.Deleting);

var downloadUrl = profiles.File("profile.png").GetDownloadUrl(3600); // Expiry defaults to 600 (10 minutes)

var uploadUrl = profiles.File("profile.png").GetUploadUrl(3600); // Expiry defaults to 600 (10 minutes)

Nitric.Run();
```

```java
import io.nitric.Nitric;
import io.nitric.resources.BucketPermission;

public class Application {
	public static void main(String[] args) {
		var profiles = Nitric.INSTANCE.bucket("profiles").with(BucketPermission.Read, BucketPermission.Write);

		var downloadUrl = profiles.file("profile.png").getDownloadUrl();

		var uploadUrl = profiles.file("profile.png").getUploadUrl();

		Nitric.INSTANCE.run();
	}
}
```

```kotlin
import io.nitric.Nitric
import io.nitric.resources.BucketPermission

fun main() {
	val profiles = Nitric.bucket("profiles").with(BucketPermission.Read, BucketPermission.Write)

	val downloadUrl = profiles.file("profile.png").getDownloadUrl()

	val uploadUrl = profiles.file("profile.png").getUploadUrl()

	Nitric.run()
}
```

</CodeGroup>

## Bucket Notifications

Bucket notifications are functions that subscribe to changes in your bucket's files. You can configure these notifications to trigger specifically when a file is written or deleted. Additionally, you can apply filters based on file prefixes to specify which files should trigger a notification. When the function is triggered, it receives event data that includes details about the changed file, such as whether it was written or deleted, and the file's name.

To illustrate, suppose we want to trigger a function whenever a new profile image is uploaded to a bucket. In this case, we can use the following code snippet:

<Note>
  Writing/Delete to a bucket from within a bucket notification will trigger the
  same notification to run again (if it meets the requirement). This will cause
  an infinite loop, which is highly undesirable for your cloud bill.
</Note>

<CodeGroup>

```javascript
import { bucket } from '@nitric/sdk'

const profiles = bucket('profiles')

// Filter for 'write' events for files starting with '/users/images'
profiles.on('write', '/users/images', (ctx) => {
  console.log(`new profile image for ${ctx.req.key} was created`)
})
```

```python
from nitric.resources import bucket
from nitric.application import Nitric

profiles = bucket("profiles")

# Filter for 'write' events for files starting with '/users/images'
@profiles.on("write", "/users/images")
async def image_written(ctx):
  print(f"new profile image for {ctx.req.key} was written")

Nitric.run()
```

```go
import (
  "context"
  "fmt"

  "github.com/nitrictech/go-sdk/faas"
  "github.com/nitrictech/go-sdk/nitric"
)

func main() {
  assets := nitric.NewBucket("assets")

  // Filter for 'write' events for files starting with '/users/images'
  assets.On(faas.WriteNotification, "/users/images", func(ctx *faas.BucketNotificationContext, _ faas.BucketNotificationHandler) (*faas.BucketNotificationContext, error) {
    fmt.Printf("new profile image for %s was written", ctx.Request.Key())

    return ctx, nil
  })

  if err := nitric.Run(); err != nil {
    fmt.Println(err)
  }
}
```

```csharp
using Nitric.Sdk;
using Nitric.Sdk.Function;
using Nitric.Sdk.Resources;

var assets = Nitric.Bucket("assets");

// Filter for 'write' events for files starting with '/users/images'
assets.On(BucketNotificationType.Write, "/users/images", ctx =>
{
  Console.WriteLine($"new profile image for {ctx.Req.Key} was written");
  return ctx;
});

Nitric.Run();
```

```java
import io.nitric.Nitric;
import io.nitric.resources.BucketPermission;
import io.nitric.faas.v0.BucketNotificationType;

public class Application {
	public static void main(String[] args) {
		var assets = Nitric.INSTANCE.bucket("assets");

		// Filter for 'write' events for files starting with '/users/images'
		assets.on(BucketNotificationType.Write, "/users/images", (ctx) -> {
			System.out.printf("new profile image for %s was written", ctx.getReq().getKey());
		});

		Nitric.INSTANCE.run();
	}
}
```

```kotlin
import io.nitric.Nitric
import io.nitric.resources.BucketPermission
import io.nitric.faas.v0.BucketNotificationType

fun main() {
	val assets = Nitric.bucket("assets")

	// Filter for 'write' events for files starting with '/users/images'
	assets.on(BucketNotificationType.Write, "/users/images") { ctx ->
		printf("new profile image for ${ctx.req.key} was written")
	}

	Nitric.run()
}
```

</CodeGroup>

If we instead wanted to trigger the function whenever any file was deleted from the bucket, we would use the following snippet:

<CodeGroup>

```javascript
import { bucket } from '@nitric/sdk'

const profiles = bucket('profiles')

// Filter for 'delete' events for any file
profiles.on('delete', '*', (ctx) => {
  console.log(`${ctx.req.key} was deleted`)
})
```

```python
from nitric.resources import bucket
from nitric.application import Nitric

profiles = bucket("profiles")

# Filter for 'delete' events for any file
@profiles.on("delete", "*")
async def file_deleted(ctx):
  print(f"{ctx.req.key} was deleted")

Nitric.run()
```

```go
import (
  "context"
  "fmt"

  "github.com/nitrictech/go-sdk/faas"
  "github.com/nitrictech/go-sdk/nitric"
)

func main() {
  assets := nitric.NewBucket("assets")

  // Filter for 'delete' events for any file
  assets.On(faas.DeleteNotification, "*", func(ctx *faas.BucketNotificationContext, _ faas.BucketNotificationHandler) (*faas.BucketNotificationContext, error) {
    fmt.Printf("%s was deleted", ctx.Request.Key())

    return ctx, nil
  })

  if err := nitric.Run(); err != nil {
    fmt.Println(err)
  }
}
```

```csharp
using Nitric.Sdk;
using Nitric.Sdk.Function;
using Nitric.Sdk.Resources;

var assets = Nitric.Bucket("assets");

// Filter for 'delete' events for any file
assets.On(BucketNotificationType.Delete, "*", ctx =>
{
  Console.WriteLine($"{ctx.Req.Key} was deleted");
  return ctx;
});

Nitric.Run();
```

```java
import io.nitric.Nitric;
import io.nitric.resources.BucketPermission;
import io.nitric.faas.v0.BucketNotificationType;

public class Application {
	public static void main(String[] args) {
		var assets = Nitric.INSTANCE.bucket("assets");

		// Filter for 'delete' events for any file
		assets.on(BucketNotificationType.Delete, "*", (ctx) -> {
			System.out.printf("%s was deleted", ctx.getReq().getKey());
		});

		Nitric.INSTANCE.run();
	}
}
```

```kotlin
import io.nitric.Nitric
import io.nitric.resources.BucketPermission
import io.nitric.faas.v0.BucketNotificationType

fun main() {
	val assets = Nitric.bucket("assets")

	// Filter for 'delete' events for any file
	assets.on(BucketNotificationType.Delete, "*") { ctx ->
		print("${ctx.req.key} was deleted")
	}

	Nitric.run()
}
```

</CodeGroup>
