---
description: "Reference for Nitric's .NET library - Register a single handler for all HTTP Methods (GET, POST, PUT, DELETE, PATCH) on the route."
---

# .NET - Api.Route.All()

<Note>
  This is reference documentation for the Nitric .NET SDK. To learn about APIs
  in Nitric start with the [API docs](/api).
</Note>

Register a single handler for all HTTP Methods (GET, POST, PUT, DELETE, PATCH) on the route.

```csharp
using Application = Nitric.Sdk.Nitric;
using System.Collections.Generic;

var route = Application.Api("main").Route("/customers");

route.All(async (ctx) => {
  // Construct a response for all incoming HTTP requests
  var responseBody = new Dictionary<string, string>();
  ctx.Res.Json(responseBody);

  return ctx;
});

Application.Run();
```

## Parameters

<Properties>
  <Property
    name="...middleware"
    type="Middleware&lt;HttpContext&gt; or Func&lt;HttpContext, HttpContext&gt;"
    required
  >
    One or more middleware functions to use as the handler for HTTP requests.
    Handlers can be sync or async.
  </Property>
</Properties>

## Notes

When using the `All()` method to register a single function as the handler for all HTTP methods, none of the other methods should be defined on that route.

```csharp
using Application = Nitric.Sdk.Nitric;

var route = Application.Api("main").Route("/customers");

route.All(async (ctx) => {
  /* handle all requests */
});

// Don't call `Get()`, `Post()`, etc., they're already handled by `all()`
route.Get(async (ctx) => {
  // This handler won't work
})

Application.Run();
```

## Examples

### Register a method handler function

```csharp
using Application = Nitric.Sdk.Nitric;
using System.Collections.Generic;

var route = Application.Api("main").Route("/customers");

route.All(async (ctx) => {
    // Construct a response for all incoming HTTP requests
    var responseBody = new Dictionary<string, string>();
    ctx.Res.Json(responseBody);

    return ctx;
});

Application.Run();
```

### Chain functions as a single method handler

When multiple functions are provided they will be called as a chain. If one succeeds, it will move on to the next. This allows middleware to be composed into more complex handlers.

```csharp
using Nitric.Sdk.Service;
using Application = Nitric.Sdk.Nitric;

var route = Application.Api("main").Route("/customers");

route.All(new Middleware<HttpContext>[] {
  async (ctx, next) => {
    var user = ctx.Req.PathParams["userId"];

    // Validate the user identity
    if (user != "1234")
    {
      ctx.Res.Text($"User {user} is unauthorised");
      ctx.Res.Status = 403;

      // Return prematurely to end the middleware chain.
      return ctx;
    }

    // Call next to continue the middleware chain.
    return next(ctx);
  }, async (ctx, next) => {
    var user = ctx.Req.PathParams["userId"];

    ctx.Res.Text($"Handling {user}");

    return next(ctx);
  }
});

Application.Run();
```

### Access the request body

For methods that include a request body, such as `POST` and `PUT`, you can access the body from the `ctx.req` object.

```csharp
using Application = Nitric.Sdk.Nitric;
using System.Collections.Generic;

var route = Application.Api("main").Route("/customers");

route.All(async (ctx) => {
  var body = ctx.Req.Json<Dictionary<string, string>>();
  // parse, validate and store the request payload...
  return ctx;
});

Application.Run();
```

### Error Handling

```csharp
using Application = Nitric.Sdk.Nitric;
using System.Collections.Generic;

var route = Application.Api("main").Route("/customers");

try {
  route.All(async (ctx) => {
    // Construct a response for all incoming HTTP requests
    var responseBody = new Dictionary<string, string>();
    ctx.Res.Json(responseBody);

    return ctx;
  });

  Application.Run();
} catch (Error err) {
  // error handling
}
```
