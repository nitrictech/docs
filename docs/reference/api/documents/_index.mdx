---
title: 'Documents Overview'
---

The Documents service provides applications with the ability to store and retrieve application state.
Nitric provides an expressive Document API to make this process as easy as possible.

The Document service provides a common programming interface across the major Cloud document databases
including AWS DynamoDB, GCP Firestore, Azure CosmosDB, and MongoDB for DigitalOcean.

## Key concepts

Documents are the unit of storage within a collection. They are a lightweight record that contains a set of fields.
Each document is identified by a unique id string.

For example an actor document with the id `robert.downey@mavel.io` might look like this:

```json
ğŸ“„ robert.downey@nitric.io
{
  "email": "robert.downey@mavel.io",
  "firstName": "Robert",
  "lastName": "Downey",
}
```

Documents can also nest complex JSON objects like maps or arrays.

```json
ğŸ“„ robert.downey@mavel.io
{
  "email": "robert.downey@mavel.io",
  "firstName": "Robert",
  "lastName": "Downey",
  "born": 1965,
  "active": true,
  "address": {
		"firstLine":  "Unit A",
		"secondLine": "10 Pearls Street",
		"city":       "Boulder",
		"state":      "CO",
		"zipCode":    80302,
	},
	"contactPrefs": [
		"email",
		"sms",
	],
}
```

### Collections

Collections provide containers for documents. In SQL database terms, a collection equates to a table.

With the Documents service, collections are schemaless and each document may contain an arbitary set of fields.
However, it is best practice for collections to have a well defined set of fields.

Continuing our example you could have an `Actors` collection for all your actor documents:

```json
ğŸ—‚ï¸ Actors [
    ğŸ“„ robert.downey@mavel.io
    {
     "first": "Robert",
     "last": "Downey Jr"
    }
    ğŸ“„ scarlett.johansson@mavel.io
    {
     "first": "Scarlett",
     "last": "Johansson"
    }
    ğŸ“„ benedict.cumberbatch@mavel.io
    {
     "first": "Benedict",
     "last": "Cumberbatch"
    }
]
```

### Stack Definition

To use Collections you need to define them as a resource in a stack file, such as `nitric.yaml`. At the root level of the stack file,
add a collections key, which contains an array of collections.

```yaml
---
collections:
  Actors: {}
```

Collections will be automatically created and configured with sensible defaults by the
Nitric CLI when deploying to a cloud environment and emulated when running and testing locally.

### Subcollections

Subcollections allow you to structure documents hierarchically creating one-to-many parent/child relationships. Subcollections become extremely useful when:

- you have a large number of child items
- your application has different query access patterns
- when you need to optimize performance or cost

Consider the example below:

```json
ğŸ—‚ï¸ Customers
    ğŸ“„ apple
    	ğŸ—‚ï¸ Orders
			ğŸ“„ tsmc-us-16ffp-77ba4c67d6c1
			ğŸ“„ tsmc-us-16ffp-e1f7ecdef392
			ğŸ“„ tsmc-us-16ffp-b56b55d5a2f2
    ğŸ“„ samsung
    	ğŸ—‚ï¸ Orders
			ğŸ“„ tsmc-ko-7ff-0ed0e9dd95ca
			ğŸ“„ tsmc-ko-7ff-4960179100d6
			ğŸ“„ tsmc-ko-7ff-b003fb8a3f14
```

Here we have a `Customers` collection with a relatively small number of documents, but each customer has an `Orders` subcollection containing many
thousands of documents. By using separate Customers and Order data we can efficiently retrieve customer records without having to pull all the
associated order data.

Subcollections are also provided with query capabilities, enabling efficient lookups of subcollection documents.

### Notes

- Nitric currently supports 1 level of subcollections under collections
