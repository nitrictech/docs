Containers provide a way to port existing applications and use your favorite frameworks to build with Nitric.

Nitric supports this capability by allowing you to write and specify your dockerfiles as part of your nitric stack.

## Properties

| **Property** | **Value**  | Required | **Description**                                                           |
| ------------ | ---------- | -------- | ------------------------------------------------------------------------- |
| context      | `string`   | Yes      | relative path to the container context                                    |
| dockerfile   | `string`   | Yes      | relative path from the context to the dockerfile describing the container |
| args         | `string[]` | No       | build arguments that will be added during the container build process     |

## Example Container Configuration

```yaml
name: example-container

containers:
  create:
    context: .
    dockerfile: docker/http.dockerfile
    args:
      HANDLER: functions/create_http/main.go
  read:
    context: .
    dockerfile: docker/function.dockerfile
    args:
      HANDLER: functions/read/main.go
```

## Example Dockerfiles

In order to fully utilize the Nitric framework the Nitric membrane should be included to isolate your application from its deployed environment.

<Accordion title="Expand for a function handler example">

```dockerfile
ARG PROVIDER=dev
FROM golang:1.17-alpine3.13 as build

ARG HANDLER

RUN apk update
RUN apk upgrade

RUN apk add --no-cache git gcc g++ make

WORKDIR /app/

# Copy dependency files
COPY go.mod *.sum ./

# Install go dependencies
RUN go mod download
RUN go mod tidy

# Copy the function source
COPY . .

# Build the function binary
RUN CGO_ENABLED=0 GOOS=linux go build -o /bin/function ./${HANDLER}

# Fresh image to remove go build packages
FROM alpine
ARG PROVIDER

# Add binaries to the path
ENV PATH="/usr/local/bin:${PATH}"

COPY --from=build /bin/function /function
RUN chmod +x-rw /function

# Expose the gateways proxy port
EXPOSE 9001/tcp

# WORKDIR required to AWS lambda deployments
WORKDIR /

ADD https://github.com/nitrictech/nitric/releases/download/v0.12.0-rc.22/membrane-$PROVIDER /usr/local/bin/membrane
RUN chmod +x-rw /usr/local/bin/membrane

# Run the Nitric Membrane
# This process will load membrane provider plugins and kick-off the userland process
# full path Entrypoint required for AWS Lambda
ENTRYPOINT ["/usr/local/bin/membrane"]

# Set membrane child process command and args
CMD ["/function"]
```

</Accordion>

<Accordion title="Expand for a http proxy example">

```dockerfile
ARG PROVIDER=dev
FROM golang:1.17-alpine3.13 as build

ARG HANDLER

RUN apk update
RUN apk upgrade

RUN apk add --no-cache git gcc g++ make

WORKDIR /app/

# Copy dependency files
COPY go.mod *.sum ./

# Install go dependencies
RUN go mod download
RUN go mod tidy

# Copy the function source
COPY . .

# Build the function binary
RUN CGO_ENABLED=0 GOOS=linux go build -o /bin/function ./${HANDLER}

# Fresh image to remove go build packages
FROM alpine
ARG PROVIDER

# Add binaries to the path
ENV PATH="/usr/local/bin:${PATH}"

COPY --from=build /bin/function /function
RUN chmod +x-rw /function

# Expose the gateways proxy port
EXPOSE 9001/tcp

# WORKDIR required to AWS lambda deployments
WORKDIR /

ADD https://github.com/nitrictech/nitric/releases/download/v0.12.0-rc.22/membrane-$PROVIDER /usr/local/bin/membrane
RUN chmod +x-rw /usr/local/bin/membrane

ENV MEMBRANE_MODE=HTTP_PROXY

# Run the Nitric Membrane
# This process will load membrane provider plugins and kick-off the userland process
# full path Entrypoint required for AWS Lambda
ENTRYPOINT ["/usr/local/bin/membrane"]

# Set membrane child process command and args
CMD ["/function"]
```

</Accordion>

It is also useful to include a `.dockerignore` file next to your `dockerfile` to exclude the `.nitric` folder and anything else you want excluded.
This will reduce your image size.
