---
description: 'Building HTTP APIs with Nitric'
---

# APIs

Nitric provides a simple and powerful way to build HTTP APIs in your applications. The `api` resource allows you to create APIs with routing, middleware, request handlers, and security features.

## Quick Start

Here's a minimal example to get you started:

<CodeSwitcher tabs>

```javascript !!
import { api } from '@nitric/sdk'

const myApi = api('my-api')

myApi.get('/hello', async (ctx) => {
  ctx.res.body = 'Hello World!'
})
```

```typescript !!
import { api } from '@nitric/sdk'

const myApi = api('my-api')

myApi.get('/hello', async (ctx) => {
  ctx.res.body = 'Hello World!'
})
```

```python !!
from nitric.resources import api
from nitric.application import Nitric

my_api = api('my-api')

@my_api.get("/hello")
async def hello(ctx):
    ctx.res.body = "Hello World!"

Nitric.run()
```

```go !!
package main

import (
  "github.com/nitrictech/go-sdk/nitric"
  "github.com/nitrictech/go-sdk/nitric/apis"
)

func main() {
  myApi := nitric.NewApi("my-api")

  myApi.Get("/hello", func(ctx *apis.Ctx) {
    ctx.Response.Body = []byte("Hello World!")
  })

  nitric.Run()
}
```

```dart !!
import 'package:nitric_sdk/nitric.dart';

final myApi = Nitric.api("my-api");

myApi.get("/hello", (ctx) async {
  ctx.res.body = "Hello World!";
  return ctx;
});
```

</CodeSwitcher>

## Core Concepts

### API Resources

Each API in your application needs a unique name. This name is used to identify the API across your project and in cloud deployments.

<CodeSwitcher tabs>

```javascript !!
const myApi = api('my-api-name')
```

```typescript !!
const myApi = api('my-api-name')
```

```python !!
my_api = api('my-api-name')
```

```go !!
myApi := nitric.NewApi("my-api-name")
```

```dart !!
final myApi = Nitric.api("my-api-name");
```

</CodeSwitcher>

### Request Context

Every handler receives a context object (`ctx`) that contains:

- `req`: The incoming request object
- `res`: The response object you'll use to send data back

### Routing

APIs support all standard HTTP methods and path-based routing:

<CodeSwitcher tabs>

```javascript !!
const myApi = api('my-api')

// GET /items
myApi.get('/items', async (ctx) => {
  ctx.res.json({ items: [] })
})

// POST /items
myApi.post('/items', async (ctx) => {
  const item = ctx.req.json()
  ctx.res.status = 201
  ctx.res.json(item)
})

// PUT /items/:id
myApi.put('/items/:id', async (ctx) => {
  const { id } = ctx.req.params
  const item = ctx.req.json()
  ctx.res.json({ id, ...item })
})
```

```typescript !!
const myApi = api('my-api')

// GET /items
myApi.get('/items', async (ctx) => {
  ctx.res.json({ items: [] })
})

// POST /items
myApi.post('/items', async (ctx) => {
  const item = ctx.req.json()
  ctx.res.status = 201
  ctx.res.json(item)
})

// PUT /items/:id
myApi.put('/items/:id', async (ctx) => {
  const { id } = ctx.req.params
  const item = ctx.req.json()
  ctx.res.json({ id, ...item })
})
```

```python !!
my_api = api('my-api')

@my_api.get("/items")
async def list_items(ctx):
    ctx.res.json({"items": []})

@my_api.post("/items")
async def create_item(ctx):
    item = ctx.req.json
    ctx.res.status = 201
    ctx.res.json(item)

@my_api.put("/items/:id")
async def update_item(ctx):
    id = ctx.req.params["id"]
    item = ctx.req.json
    ctx.res.json({"id": id, **item})
```

```go !!
myApi := nitric.NewApi("my-api")

myApi.Get("/items", func(ctx *apis.Ctx) {
    ctx.Response.Json(map[string]interface{}{"items": []})
})

myApi.Post("/items", func(ctx *apis.Ctx) {
    item := ctx.Request.Json()
    ctx.Response.Status = 201
    ctx.Response.Json(item)
})

myApi.Put("/items/:id", func(ctx *apis.Ctx) {
    id := ctx.Request.PathParams()["id"]
    item := ctx.Request.Json()
    ctx.Response.Json(map[string]interface{}{"id": id, "item": item})
})
```

```dart !!
final myApi = Nitric.api("my-api");

myApi.get("/items", (ctx) async {
  ctx.res.json({"items": []});
  return ctx;
});

myApi.post("/items", (ctx) async {
  final item = ctx.req.json;
  ctx.res.status = 201;
  ctx.res.json(item);
  return ctx;
});

myApi.put("/items/:id", (ctx) async {
  final id = ctx.req.pathParams["id"];
  final item = ctx.req.json;
  ctx.res.json({"id": id, ...item});
  return ctx;
});
```

</CodeSwitcher>

### Path Parameters

You can define dynamic routes using path parameters:

<CodeSwitcher tabs>

```javascript !!
myApi.get('/users/:id', async (ctx) => {
  const { id } = ctx.req.params
  ctx.res.json({ id })
})
```

```typescript !!
myApi.get('/users/:id', async (ctx) => {
  const { id } = ctx.req.params
  ctx.res.json({ id })
})
```

```python !!
@my_api.get("/users/:id")
async def get_user(ctx):
    id = ctx.req.params["id"]
    ctx.res.json({"id": id})
```

```go !!
myApi.Get("/users/:id", func(ctx *apis.Ctx) {
    id := ctx.Request.PathParams()["id"]
    ctx.Response.Json(map[string]interface{}{"id": id})
})
```

```dart !!
myApi.get("/users/:id", (ctx) async {
  final id = ctx.req.pathParams["id"];
  ctx.res.json({"id": id});
  return ctx;
});
```

</CodeSwitcher>

## Advanced Features

### Middleware

Middleware allows you to add common functionality across routes. Each middleware receives the context and a `next` function to continue the request chain:

<CodeSwitcher tabs>

```javascript !!
async function authMiddleware(ctx, next) {
  const token = ctx.req.headers['authorization']
  if (!token) {
    ctx.res.status = 401
    return ctx
  }
  return await next(ctx)
}

const secureApi = api('secure-api', {
  middleware: [authMiddleware],
})
```

```typescript !!
async function authMiddleware(ctx, next) {
  const token = ctx.req.headers['authorization']
  if (!token) {
    ctx.res.status = 401
    return ctx
  }
  return await next(ctx)
}

const secureApi = api('secure-api', {
  middleware: [authMiddleware],
})
```

```python !!
async def auth_middleware(ctx, next):
    token = ctx.req.headers.get("authorization")
    if not token:
        ctx.res.status = 401
        return ctx
    return await next(ctx)

secure_api = api("secure-api", opts=ApiOptions(middleware=[auth_middleware]))
```

```go !!
func authMiddleware(next apis.Handler) apis.Handler {
    return func(ctx *apis.Ctx) error {
        if ctx.Request.Headers()["authorization"] == nil {
            ctx.Response.Status = 401
            return nil
        }
        return next(ctx)
    }
}

secureApi := nitric.NewApi("secure-api", apis.WithMiddleware(authMiddleware))
```

```dart !!
Future<HttpContext> authMiddleware(HttpContext ctx) async {
  if (!ctx.req.headers.containsKey("authorization")) {
    ctx.res.status = 401;
    return ctx;
  }
  return ctx.next();
}

final secureApi = Nitric.api(
  "secure-api",
  opts: ApiOptions(middlewares: [authMiddleware])
);
```

</CodeSwitcher>

### Security

APIs can be secured using OIDC-compatible providers like Auth0, FusionAuth, or AWS Cognito. Security can be applied at the API level or per route:

<CodeSwitcher tabs>

```javascript !!
import { api, oidcRule } from '@nitric/sdk'

const auth0Rule = oidcRule({
  name: 'auth0',
  issuer: 'https://your-tenant.auth0.com',
  audiences: ['your-api-identifier'],
})

const secureApi = api('secure-api', {
  security: [auth0Rule('user.read')],
})
```

```typescript !!
import { api, oidcRule } from '@nitric/sdk'

const auth0Rule = oidcRule({
  name: 'auth0',
  issuer: 'https://your-tenant.auth0.com',
  audiences: ['your-api-identifier'],
})

const secureApi = api('secure-api', {
  security: [auth0Rule('user.read')],
})
```

```python !!
from nitric.resources import api, ApiOptions, oidc_rule

auth0_rule = oidc_rule(
    name="auth0",
    issuer="https://your-tenant.auth0.com",
    audiences=["your-api-identifier"]
)

secure_api = api("secure-api", opts=ApiOptions(
    security=[auth0_rule("user.read")]
))
```

```go !!
auth0Rule := apis.OidcRule(
    "auth0",
    "https://your-tenant.auth0.com/.well-known/openid-configuration",
    []string{"your-api-identifier"},
)

secureApi := nitric.NewApi(
    "secure-api",
    apis.WithSecurity(auth0Rule([]string{"user.read"})),
)
```

```dart !!
final auth0Rule = Nitric.oidcRule(
  "auth0",
  "https://your-tenant.auth0.com",
  ["your-api-identifier"]
);

final secureApi = Nitric.api(
  "secure-api",
  opts: ApiOptions(
    security: [auth0Rule(["user.read"])]
  )
);
```

</CodeSwitcher>

### Custom Domains

You can configure custom domains for your APIs in your stack configuration:

<Tabs>

<TabItem label="AWS">

```yaml title:nitric.prod.yaml
provider: nitric/aws@1.1.0
region: us-east-1

apis:
  my-api:
    domains:
      - api.example.com
```

</TabItem>

<TabItem label="Azure">

```yaml title:nitric.prod.yaml
# Currently unsupported - request support here: https://github.com/nitrictech/nitric/issues
```

</TabItem>

<TabItem label="GCP">

```yaml title:nitric.prod.yaml
# Currently unsupported - request support here: https://github.com/nitrictech/nitric/issues
```

</TabItem>

</Tabs>

<Note>
  Custom domains are currently only supported for AWS deployments. See the [AWS
  Custom Domain Setup](/providers/mappings/aws/apis#custom-domain-prerequisites)
  section for setup details.
</Note>

## Project Organization

### Multiple Services

You can split your API routes across multiple services while using the same API resource:

<CodeSwitcher tabs>

```javascript !! title:services/users.js
import { api } from '@nitric/sdk'

const myApi = api('my-api')

myApi.get('/users', async (ctx) => {
  // Handle user listing
})
```

```typescript !! title:services/users.ts
import { api } from '@nitric/sdk'

const myApi = api('my-api')

myApi.get('/users', async (ctx) => {
  // Handle user listing
})
```

```python !! title:services/users.py
from nitric.resources import api
from nitric.application import Nitric

my_api = api('my-api')

@my_api.get("/users")
async def list_users(ctx):
    // Handle user listing
    pass

Nitric.run()
```

```go !! title:services/users/main.go
package main

import (
  "github.com/nitrictech/go-sdk/nitric"
  "github.com/nitrictech/go-sdk/nitric/apis"
)

func main() {
  myApi := nitric.NewApi("my-api")

  myApi.Get("/users", func(ctx *apis.Ctx) {
    // Handle user listing
  })

  nitric.Run()
}
```

```dart !! title:services/users.dart
import 'package:nitric_sdk/nitric.dart';

final myApi = Nitric.api("my-api");

myApi.get("/users", (ctx) async {
  // Handle user listing
  return ctx;
});
```

</CodeSwitcher>

<CodeSwitcher tabs>

```javascript !! title:services/products.js
import { api } from '@nitric/sdk'

const myApi = api('my-api')

myApi.get('/products', async (ctx) => {
  // Handle product listing
})
```

```typescript !! title:services/products.ts
import { api } from '@nitric/sdk'

const myApi = api('my-api')

myApi.get('/products', async (ctx) => {
  // Handle product listing
})
```

```python !! title:services/products.py
from nitric.resources import api
from nitric.application import Nitric

my_api = api('my-api')

@my_api.get("/products")
async def list_products(ctx):
    // Handle product listing
    pass

Nitric.run()
```

```go !! title:services/products/main.go
package main

import (
  "github.com/nitrictech/go-sdk/nitric"
  "github.com/nitrictech/go-sdk/nitric/apis"
)

func main() {
  myApi := nitric.NewApi("my-api")

  myApi.Get("/products", func(ctx *apis.Ctx) {
    // Handle product listing
  })

  nitric.Run()
}
```

```dart !! title:services/products.dart
import 'package:nitric_sdk/nitric.dart';

final myApi = Nitric.api("my-api");

myApi.get("/products", (ctx) async {
  // Handle product listing
  return ctx;
});
```

</CodeSwitcher>

### Shared Resources

For better organization, you can define shared API resources:

<CodeSwitcher tabs>

```javascript !! title:resources/api.js
import { api } from '@nitric/sdk'

export const myApi = api('my-api')
```

```typescript !! title:resources/api.ts
import { api } from '@nitric/sdk'

export const myApi = api('my-api')
```

```python !! title:resources/api.py
from nitric.resources import api

my_api = api('my-api')
```

```go !! title:resources/api/main.go
package api

import (
  "github.com/nitrictech/go-sdk/nitric"
  "github.com/nitrictech/go-sdk/nitric/apis"
)

var MyApi apis.Api

func init() {
  MyApi = nitric.NewApi("my-api")
}
```

```dart !! title:resources/api.dart
import 'package:nitric_sdk/nitric.dart';

final myApi = Nitric.api("my-api");
```

</CodeSwitcher>

Then import and use them in your services:

<CodeSwitcher tabs>

```javascript !! title:services/users.js
import { myApi } from '../resources/api'

myApi.get('/users', async (ctx) => {
  // Handle user listing
})
```

```typescript !! title:services/users.ts
import { myApi } from '../resources/api'

myApi.get('/users', async (ctx) => {
  // Handle user listing
})
```

```python !! title:services/users.py
from nitric.application import Nitric
from resources.api import my_api

@my_api.get("/users")
async def list_users(ctx):
    // Handle user listing
    pass

Nitric.run()
```

```go !! title:services/users/main.go
package main

import (
  "your-project/resources/api"
  "github.com/nitrictech/go-sdk/nitric"
  "github.com/nitrictech/go-sdk/nitric/apis"
)

func main() {
  api.MyApi.Get("/users", func(ctx *apis.Ctx) {
    // Handle user listing
  })

  nitric.Run()
}
```

```dart !! title:services/users.dart
import '../resources/api.dart';

myApi.get("/users", (ctx) async {
  // Handle user listing
  return ctx;
});
```

</CodeSwitcher>

## Cloud Provider Support

Each cloud provider has specific features and limitations for API deployments:

- [AWS](/providers/mappings/aws/apis)
- [Azure](/providers/mappings/azure/apis)
- [Google Cloud](/providers/mappings/gcp/apis)

<Note>Security rules are not enforced during local development.</Note>
