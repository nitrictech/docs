## Introduction
A sample project which demonstrates a basic sign up form using Nitric FaaS and Collections.
This code serves as a tutorial for educational purposes and non production usage.

## What we'll do

- Create a new Nitric project
- Create [functions](../services-functions.mdx) to handle the signup operation
- Create a [documents](../documents.mdx) collection to store data
- Create basic react app to consume the signup operation
- Get it all running locally for testing
- Deploy to a cloud of your choice

> This tutorial provides examples in TypeScript & Go

## Getting started

This tutorial assumes you have the Nitric CLI installed, if not you can follow the [installation guide](/docs/installation).

You'll also want to setup your environment to run and test Nitric applications locally by installing prerequisite software. Use the `nitric doctor` command to check and automatically setup your machine.

If youâ€™d like to deploy the results to a cloud environment _(optional)_, youâ€™ll also need to setup your credentials and any other cloud specific configuration: [AWS](/docs/provider-aws), [GCP](/docs/provider-gcp), or [Azure](/docs/provider-azure).

## New project

Weâ€™ll start by creating a new project.

```bash
nitric make:project my-signup-app
```

```text
? Include an example service? function/golang15
? Name for the example function? signup
âœ” Making Project my-signup-app
âœ” Making Function signup
```

Next, open the project in your editor of choice. The scaffolded project should have the following structure:  

```text
my-signup-app/
|
+--nitric.yaml
+--signup/
   |
   +--go.mod
   +--go.sum
   +--main.go
```

## Coding

Open the main.go file, and let's start coding - 

We'll need the following import statements:
```golang15
package main

import (
	"encoding/base64"
	"encoding/json"
	"net/http"

	"github.com/fatih/structs"
	"github.com/nitrictech/go-sdk/api/documents"
	"github.com/nitrictech/go-sdk/faas"
	satori "github.com/satori/go.uuid"
)
```
## Constants and Structs

| **Name**       | **Description**                |
| -----------------| ------------------------------ |
| COLLECTION_USER  | Name of the Users document collection (must match definition in .yaml config                |
| InputData        | A struct to store the input json of format - { "email": "abc@abc.com", "password": "top-secret" } |
| UserRow          | The format of the data which we'll preserve in our Users collection            |
| Resp             | The format we'll store our response in


```golang15
const (
	COLLECTION_USER = "Users"
)

// Format of incoming JSON Data
type InputData struct {
	Email    string
	Password string
}

// Data to be stored in User Collection
type UserRow struct {
	Userid   string
	Email    string
	Password string
	PwsHash  string
}

// Response format 
type Resp struct {
	Status  string
	Message string
}
```
## Helper functions 

Now let's create some functions which will help us get a user created:

| **Method**       | **Description**                |
| -----------------| ------------------------------ |
| marshalInput     | Construct our InputData Struct with base64 (optional) encoded json                |
| responseMessage  | Construct return json { "status": "ok", "message": "body" }  |
| userExists       | Check the collection for the existence of a user with "email" input            |
| main             | Run NitricFunction - Nitric Function as a Service operations            |



```golang15
// Marshal the input data into a struct for ease of use
func marshalInput(trigger *faas.NitricTrigger, ed *InputData) {
	td, err := base64.StdEncoding.DecodeString(string(trigger.GetData()))
	if err != nil {
		td = trigger.GetData()
	}
	json.Unmarshal(td, &ed)
}

// Create a response []byte containing the status and message 
func responseMessage(status string, message string) []byte {
	r1 := &Resp{Status: status, Message: message}
	r2, _ := json.Marshal(r1)
	return r2
}


// Check the User Collection to see if the user already exists
func userExists(email string) bool {
	docs, _ := documents.New()

	query := docs.Collection(COLLECTION_USER).Query()
	results, _ := query.Fetch()

	for _, result := range results.Documents {
		var row UserRow
		result.Decode(&row)

		if row.Email == email {
			return true
		}
	}
	return false
}

func main() {
	faas.Start(NitricFunction)
}
```

## Nitric Function

Let's pull it all together, modify or create the 'NitricFunction' function -

```golang15
// NitricFunction - Handles individual function requests (http, events, etc.)
func NitricFunction(trigger *faas.NitricTrigger) (*faas.NitricResponse, error) {

	// Add the code for the following steps here 
	
}
```

We first initialize our input data, create a user id and set up our Collection to be used.

```golang15
	// Convert the input data into a format we can easily consume
	var inputData InputData
	marshalInput(trigger, &inputData)

	// Create a new user ID
	uid := satori.NewV4().String()

	// Initialize the User Collection 
	docs, _ := documents.New()
	appData := docs.Collection(COLLECTION_USER).Doc(uid)
```

Next we'll set up our User Row, we'll keep it simple here by storing our password in plain text.

```
	// Construct our User Row
	userRow := &UserRow{
		Userid:   uid,
		Email:    inputData.Email,
		Password: inputData.Password,
		PwsHash:  "TODO",
	}
  
```

Finally, attempt to store the user in our collection and return a response 

```golang15
	// Initialize our default response (HTTP Status OK)
	response := trigger.DefaultResponse()

	// Check to make sure the user doesn't already exist
	if userExists(inputData.Email) {
		response.GetContext().AsHttp().Status = http.StatusUnauthorized
		response.SetData(responseMessage("Error", "Account already exists."))
		return response, nil
	}

	// TODO: Handle this error more appropriately for a real world scenario
	err := appData.Set(structs.Map(userRow))
	if err != nil {
		response.SetData(responseMessage("Error", "Oops something went wrong ..."))
		return response, nil
	}

	response.SetData(responseMessage("Success", "Signup success !!!"))
	return response, nil
```

The final code should look like this: 

```golang15
// NitricFunction - Handles individual function requests (http, events, etc.)
func NitricFunction(trigger *faas.NitricTrigger) (*faas.NitricResponse, error) {

	// Convert the input data into a format we can easily consume
	var inputData InputData
	marshalInput(trigger, &inputData)

	// Create a new user ID
	uid := satori.NewV4().String()

	// Initialize the User Collection 
	docs, _ := documents.New()
	appData := docs.Collection(COLLECTION_USER).Doc(uid)

	// Construct our User Row
	userRow := &UserRow{
		Userid:   uid,
		Email:    inputData.Email,
		Password: inputData.Password,
		PwsHash:  "TODO",
	}
  
	// Initialize our default response (HTTP Status OK)
	response := trigger.DefaultResponse()

	// Check to make sure the user doesn't already exist
	if userExists(inputData.Email) {
		response.GetContext().AsHttp().Status = http.StatusUnauthorized
		response.SetData(responseMessage("Error", "Account already exists."))
		return response, nil
	}

	// TODO: Handle this error more appropriately for a real world scenario
	err := appData.Set(structs.Map(userRow))
	if err != nil {
		response.SetData(responseMessage("Error", "Oops something went wrong ..."))
		return response, nil
	}

	response.SetData(responseMessage("Success", "Signup success !!!"))
	return response, nil
}
```

Optional - you might want to trigger an event at this point to inform services who subscribe to topic "user-created".

Import statement:
```
	"github.com/nitrictech/go-sdk/api/events"
```

Event triggering code:
```
	e, _ := events.New()
	_, err = e.Topic("user-created").Publish(&events.Event{
		Payload: map[string]interface{}{
			"eventid": satori.NewV4().String(),
			"email":   inputData.Email,
		},
	})
```		
Don't forget to add the topic to the nitric.yaml file

```json

name: my-signup-app
services:
  signup:
    path: signup
    runtime: function/golang15
collections:
  Users: {}
topics:
  user-created: {}  

  ...

```

## Updating our yaml file 

We'll need to get our Collection and API configured in our nitric.yaml file:

```yaml
name: my-signup-app
services:
  signup:
    path: signup
    runtime: function/golang15
collections:
  Users: {}
apis:
  onboarding:
    openapi: 3.0.0
    info:
      version: 1.0.0
      title: Onboarding API
      description: Handle all onboarding requests
    paths:
      /signup:
        post:
          operationId: signup
          x-nitric-target:
            name: signup
            type: service
          description: Create a username and password combination
          responses:
            "200":
              description: Successful response
entrypoints:
  main:
    paths:    
      /signup/:
        type: service
        target: signup			  
```

## Run the service

First we will start our service using this command:

```bash
nitric run
```

Once built and running you should see the following output:

```bash
âœ” Building Services
âœ” Creating docker network
âœ” Creating Volume: my-login-app
âœ” Running Services
âœ” Starting API Gateways
âœ” Starting Entrypoints
Service    Port
main    49152
Running, press 'Q' to clean up and exit...
```

Run the cURL command substituting the port 49152 with the outputted port from the `nitric run` command:

```bash
curl -H "Content-Type: application/json" -d "{\"email\":\"test@nitric.io\", \"password\":\"Nitric\"}" http://localhost:49152/signup
```

This will give us a response JSON:

```bash
{"Status":"Success", "Message Signup success !!!"}
```

On second run with the same identity, you should receive:

```bash
{"Status":"Error","Message":"Account already exists."}
```

We now know our service is working the way we want and can move on to building the react app.

As a challenge, you may want to add
- Error handling for invalid json 
- Password hashing

## Building the App

We will now look at creating a React app which will utilize our new `signup` service.

### Initialize a React app

We can use <a href="https://create-react-app.dev/docs/getting-started/" target="_blank">Create React App</a> to initialize a TypesScript app.

In the `my-signup-app` project directory run:

```bash
npx create-react-app signup-ui --template typescript
cd signup-ui
```

Let's strip it down to the essentials, delete all files until the structure is as shown below: 

```bash
signup-ui
|-- node_modules
|-- public
|   |-- index.html
|-- src
|   |-- App.tsx
|   |-- index.tsx
|	|-- index.css
|-- .gitignore
|-- package.json
|-- README.md
|-- tsconfig.json
|-- yarn.lock
```

Let's replace index.html - we're really only wanting to get the page title set up here

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Nitric Demonstration.</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.
      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.
      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
```

Update the index.tsx file to use our css:

```
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);
```


Optional - Update the CSS file contents - index.css  

<details>
	<summary>Click to expand</summary>

```css
html,
body {
  --theme-font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto,
    Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
  --theme-bg-color: #fff;
  --theme-text-color: #48486a;
  --theme-box-shadow: 0px 2px 4px -1px rgb(0 0 0 / 20%),
    0px 4px 5px 0px rgb(0 0 0 / 14%), 0px 1px 10px 0px rgb(0 0 0 / 12%);
  --theme-color-brand: #ff9b01;
  --theme-color-secondary: #5c629e;
  --theme-border: 1px solid var(--theme-color-secondary);
  --theme-spacing: 40px;

  padding: 0;
  margin: 0;
  font-family: var(--theme-font-family);
  background-color: var(--theme-bg-color);
}

* {
  box-sizing: border-box;
}

label {
  display: block;
  margin: 5px 0;
  color: var(--theme-color-secondary);
  font-size: 1rem;
  font-weight: 600;
}

input {
  width: 100%;
  border: none;
  font-size: 1.2rem;
  padding: 8px;
  border: var(--theme-border);
  border-radius: 4px;
  background-color: var(--theme-bg-color);
  color: var(--theme-text-color);
}

h1,
h2 {
  color: var(--theme-text-color);
  font-size: 2.6rem;
  margin: 0;
  padding: 0;
}

/* Button */

button {
  color: var(--theme-color-secondary);
  background-color: var(--theme-bg-color);
  text-align: center;
  letter-spacing: 1px;
  margin: 0;
  width: 100%;
  border-radius: var(--theme-border-radius);
  padding: 1rem 2rem;
  cursor: pointer;
  text-align: center;
  font-size: 1.4rem;
  border-radius: 42px;
  border: none;
  box-shadow: var(--theme-box-shadow);
  transition: all 0.3s ease-in-out;
}

button.primary:hover {
  background-color: #d48000;
}

button.primary {
  background-color: var(--theme-color-brand);
  border: 1px solid var(--theme-color-brand);
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

button > .loader {
  display: inline-block;
}

button > .loader.loading {
  animation: spin 1s linear infinite;
}

.form-grid {
  display: grid;
  gap: calc(var(--theme-spacing) / 2);
}

.container {
  margin-left: auto;
  margin-right: auto;
}

@media only screen and (min-width: 60em) {
  /* 960px */
  .container {
    max-width: 800px;
  }

  .form-grid {
    gap: var(--theme-spacing);
    grid-template-columns: repeat(2, 1fr);
  }
}

.grid {
  display: grid;
  gap: var(--theme-spacing);
  grid-template-columns: repeat(1, 1fr);
}

.center {
  display: flex;
  justify-content: center;
  align-items: center;
  padding-bottom: 50px;
  padding-top: 50px;
}

.response {
  text-align: center;
  font-size: 1rem;
  padding-top: 10px;
}

@keyframes wave {
  from {
    transform: rotate(0deg);
  }
  50% {
    transform: rotate(20deg);
  }
  to {
    transform: rotate(0deg);
  }
}

.wave {
  display: inline-block;
  padding: 0px 15px;
  animation: wave 2.4s linear infinite;
}
```	
		



	
</details>

Finally, let's build our App.tsx

```typescript
import React, { SyntheticEvent, useState } from 'react';

const App = () => {

  // Store state of email, password, loading status, signup message  
  const [signupEmail, setSignupEmail] = useState('');
  const [signupPassword, setSignupPassword] = useState('');

  const [loading, setLoading] = useState(false);
  const [signupResponse, setSignupResponse] = useState('');

  // Invoke POST operation on signup service  
  async function signup(e: SyntheticEvent) {
    e.preventDefault();
    try {
      setLoading(true);
      const rawResponse = await fetch('/signup/', {
        method: 'POST',
        credentials: 'include',
        body: JSON.stringify({
          email: signupEmail,
          password: signupPassword,
        }),
      });
      const resp = await rawResponse.json();
      setSignupResponse(resp.Message);
    } catch (error) {
      alert(error.message);
    } finally {
      setLoading(false);
    }
  }

  // Create HTML for the fields and signup button.
  return (
    <div>
      <div className="center">
        <div className="container grid">
          <h1>Signup</h1>
          <div className="form-grid">
            <div className="field">
              <label htmlFor="email">Email</label>
              <input
                id="email"
                type="text"
                value={signupEmail}
                onChange={(e) => setSignupEmail(e.target.value)}
              />
            </div>
            <div className="field">
              <label htmlFor="password">Password</label>
              <input
                id="password"
                type="password"
                value={signupPassword}
                onChange={(e) => setSignupPassword(e.target.value)}
              />
            </div>
          </div>
          <button className="primary" onClick={signup}>
            {loading ? 'Loading... ' : 'Signup'}
            <div className={loading ? 'loader loading' : 'loader'}>ðŸš€</div>
          </button>
          {signupResponse && (
            <h2 className="response">
              {signupResponse} <div className="wave">ðŸ‘‹</div>
            </h2>
          )}
        </div>
      </div>
    </div>
      
  );
};

export default App;
```

Once again we'll need to modify our nitric.yaml file to add our new site.

```
name: my-signup-app
services:
  signup:
    path: signup
    runtime: function/golang15
collections:
  Users: {}
apis:
  onboarding:
    openapi: 3.0.0
    info:
      version: 1.0.0
      title: Onboarding API
      description: Handle all onboarding requests
    paths:
      /signup:
        post:
          operationId: signup
          x-nitric-target:
            name: signup
            type: service
          description: Create a username and password combination
          responses:
            "200":
              description: Successful response
sites:
  signup-ui:
    path: signup-ui
    assetPath: ./build
    buildScripts:
      - yarn build
entrypoints:
  main:
    paths:   
      /:
        type: site
        target: signup-ui 
      /signup/:
        type: service
        target: signup
```

## Run the service

Time to run our project, and see it in action!

```bash
nitric run
```

Take note of the entry point URL, paste it in a browser to test it out.
```bash
âœ” Building Services
âœ” Creating docker network
âœ” Creating Volume: my-signup-app-vol-930352ad
âœ” Running Services
âœ” Starting API Gateways
âœ” Starting Entrypoints
 Service Port  
 â”€â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€ 
 signup  36721 
 Api        Port  
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€ 
 onboarding 49155 
 Entrypoint Url                    
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
 main       http://localhost:33881 
 Running, press 'Q' to clean up and exit...
```

Once you're happy that everything is running correctly, you can deploy your API application to a cloud provider of your choice.

```bash
# Deploy to AWS
nitric deploy:aws

# Deploy to Google Cloud
nitric deploy:gcp

# Deploy to Azure
nitric deploy:azure
```




