## Introduction

This guide will expand upon the signup & login tutorial.
Users can now signup and login, let's let them logout.

## What we'll do

- Create a new Nitric project
- Create [functions](../services-functions.mdx) to handle the login operation
- Update a basic react app to consume the login operation
- Get it all running locally for testing
- Deploy to a cloud of your choice

> This tutorial provides examples in TypeScript & Go

## Getting started

This guide assumes you have successfully completed the signup & login tutorials.

## New service

Weâ€™ll start by creating a new service within our signup project

```bash
nitric make:service
```

```text
? Service template function/golang15
? Service name logout
âœ” Making Service logout
```

## Coding

Open the main.go file in the logout directory, and let's start coding -

We'll need the following import statements:

```golang15
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"

	"github.com/dgrijalva/jwt-go"
	"github.com/nitrictech/go-sdk/api/documents"
	"github.com/nitrictech/go-sdk/faas"
)
```

## Constants and Structs

Now let's create some constants and structs to define the data being used:

| **Name**          | **Description**                                                              |
| ----------------- | ---------------------------------------------------------------------------- |
| COLLECTION_USER   | Name of the Users document collection (must match definition in .yaml config |
| COLLECTION_TOKENS | Name of the Token document collection (must match definition in .yaml config |
| TokenRow          | The format of the data which we'll preserve in our Token collection          |
| Resp              | The format we'll store our response in                                       |

```golang15
const (
	COLLECTION_USER   = "Users"
	COLLECTION_TOKENS = "Tokens"
)

// Format of data to be stored in Tokens Collection
type TokenRow struct {
	Token  string
	Expiry string
	Userid string
}

// Format of outgoing JSON Data
type Resp struct {
	Status  string
	Message string
}
```

## Helper functions

Now let's create some functions which will help us get a token created for our user:

| **Name**               | **Description**                                                                          |
| ---------------------- | ---------------------------------------------------------------------------------------- |
| responseMessage        | Construct return json { "status": "ok", "refreshtoken": "token ...", "message": "body" } |
| ExtractToken           | Extract the token from the headers                                                       |
| Auth                   | Verify the claims in the token                                                           |
| VerifyToken            | Verify the signing method of the token as SigningMethodHMAC                              |
| TokenExists            | Confirm that the token exists in the Tokens collection                                   |
| RemoveTokenDetails     | Remove the row associated with the token passed in                                       |
| RemoveAllTokensForUser | Remove any other lingering tokens for the user                                           |
| main                   | Run NitricFunction - Nitric Function as a Service operations                             |

```golang15
// Fetch the token from the cookie property in the HEADER map
func ExtractToken(headers map[string]string) string {
	cookie := headers["Cookie"]
	if cookie != "" {
		strArr := strings.Split(cookie, "=")
		if len(strArr) == 2 {
			return strArr[1]
		}
	}
	return ""
}

// Verify the Authenticity of the Token
func Auth(tokenString string, secret string) (bool, jwt.MapClaims) {
	token, err := VerifyToken(tokenString, secret)
	if err != nil || !token.Valid {
		return false, nil
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return false, nil
	}
	return true, claims
}

// Verify that the token information is valid and confirms to "SigningMethodHMAC"
func VerifyToken(tokenString string, secret string) (*jwt.Token, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(secret), nil
	})
	if err != nil {
		return nil, err
	}
	return token, nil
}

// Verify that the token exists in the Collection
func TokenExists(uuid string, uid string) bool {
	docs, _ := documents.New()
	row, err := docs.Collection(COLLECTION_TOKENS).Doc(uuid).Get()

	if err != nil {
		return false
	}

	var rr TokenRow
	row.Decode(&rr)
	return rr.Userid == uid
}

// Remove the row associated with the token passed in
func RemoveTokenDetails(tokenid string) error {
	docs, _ := documents.New()
	tokenData := docs.Collection(COLLECTION_TOKENS).Doc(tokenid)
	return tokenData.Delete()
}

// Remove the row associated with the user
func RemoveAllTokensForUser(userid string) {
	docs, _ := documents.New()
	query := docs.Collection(COLLECTION_TOKENS).Query().Where(
		documents.Condition("Userid").Eq(documents.StringValue(userid)),
	)
	results, _ := query.Fetch()

	for _, result := range results.Documents {
		result.Ref().Delete()
	}
}

// Marshal the input data into a struct for ease of use
func responseMessage(status string, message string) []byte {
	r1 := &Resp{Status: status, Message: message}
	r2, _ := json.Marshal(r1)
	return r2
}

// Set up the environment secrets and run the Nitric function
func main() {
	//TODO: These values should be stored in SECRETS or ENV
	os.Setenv("ACCESS_SECRET", "jdnfksdmfksd")
	os.Setenv("REFRESH_SECRET", "mcmvmkmsdnfsdmfdsjf")

	faas.Start(NitricFunction)
}

```

## Nitric Function

Let's pull it all together, modify or create the 'NitricFunction' function -

```golang15
// NitricFunction - Handles individual function requests (http, events, etc.)
func NitricFunction(trigger *faas.NitricTrigger) (*faas.NitricResponse, error) {

	// Add the code for the following steps here

}
```

Verify the authenticity of the token and check it exists in our Tokens collection, throw a 403 if we are unable to verify the token information.

```golang15
	response := trigger.DefaultResponse()

	// Verify the authenticity of the token and check it exists
	ok, claims := Auth(ExtractToken(trigger.GetContext().AsHttp().Headers), os.Getenv("ACCESS_SECRET"))
	uid, _ := claims["user_id"].(string)
	aid, _ := claims["access_uuid"].(string)
	if !ok || !TokenExists(aid, uid) {
		response.SetData(responseMessage("Error", "Authorization token not found or is not valid."))
		response.GetContext().AsHttp().Status = http.StatusUnauthorized
		return response, nil
	}
```

Otherwise, proceed by removing all tokens associated with the user

```golang15
	err := RemoveTokenDetails(claims["access_uuid"].(string))
	if err != nil {
		response.SetData(responseMessage("Error", "Authorization token not found or is not valid. 2"))
		response.GetContext().AsHttp().Status = http.StatusUnauthorized
		return response, nil
	}

	RemoveAllTokensForUser(claims["user_id"].(string))
	response.SetData(responseMessage("Success", "Logout successful!!!"))
	return response, nil
```

The final code should look like this:

```golang15
// NitricFunction - Handles individual function requests (http, events, etc.)
func NitricFunction(trigger *faas.NitricTrigger) (*faas.NitricResponse, error) {

	response := trigger.DefaultResponse()

	// Verify the authenticity of the token and check it exists
	ok, claims := Auth(ExtractToken(trigger.GetContext().AsHttp().Headers), os.Getenv("ACCESS_SECRET"))
	uid, _ := claims["user_id"].(string)
	aid, _ := claims["access_uuid"].(string)
	if !ok || !TokenExists(aid, uid) {
		response.SetData(responseMessage("Error", "Authorization token not found or is not valid."))
		response.GetContext().AsHttp().Status = http.StatusUnauthorized
		return response, nil
	}

	err := RemoveTokenDetails(claims["access_uuid"].(string))
	if err != nil {
		response.SetData(responseMessage("Error", "Authorization token not found or is not valid. 2"))
		response.GetContext().AsHttp().Status = http.StatusUnauthorized
		return response, nil
	}

	RemoveAllTokensForUser(claims["user_id"].(string))
	response.SetData(responseMessage("Success", "Logout successful!!!"))
	return response, nil
}
```

## Update the Nitric yaml file

Add the following to our configuration

- Logout service
- Logout entry point
- Logout API definition (Note: this is a GET operation)

```
name: my-signup-app
services:
  signup:
    path: signup
    runtime: function/golang15
  login:
    path: login
    runtime: function/golang15
  logout:
    path: logout
    runtime: function/golang15
collections:
  Users: {}
  Tokens: {}
apis:
  onboarding:
    openapi: 3.0.0
    info:
      version: 1.0.0
      title: Onboarding API
      description: Handle all onboarding requests
    paths:
      /logout:
        get:
          operationId: login
          x-nitric-target:
            name: login
            type: service
          description: Removes all tokens associated with the user
          responses:
            "200":
              description: Successful response
      /login:
        post:
          operationId: login
          x-nitric-target:
            name: login
            type: service
          description: Test a username against a password in the system
          responses:
            "200":
              description: Successful response
      /signup:
        post:
          operationId: signup
          x-nitric-target:
            name: signup
            type: service
          description: Create a username and password combination
          responses:
            "200":
              description: Successful response
sites:
  signup-ui:
    path: signup-ui
    assetPath: ./build
    buildScripts:
      - yarn build
entrypoints:
  main:
    paths:
      /:
        type: site
        target: signup-ui
      /signup/:
        type: service
        target: signup
      /login/:
        type: service
        target: login
      /logout/:
        type: service
        target: logout
```

## Modify our react app

Finally, let's modify our App.tsx to add a login section.

```typescript
import React, { SyntheticEvent, useState } from 'react';

const App = () => {
  const [loginEmail, setLoginEmail] = useState('');
  const [loginPassword, setLoginPassword] = useState('');

  const [signupEmail, setSignupEmail] = useState('');
  const [signupPassword, setSignupPassword] = useState('');

  const [loading, setLoading] = useState(false);

  const [loginResponse, setLoginResponse] = useState('');
  const [signupResponse, setSignupResponse] = useState('');

  const [refreshToken, setRefreshToken] = useState('');

  async function login(e: SyntheticEvent) {
    e.preventDefault();
    try {
      setLoading(true);
      const rawResponse = await fetch('/login/', {
        method: 'POST',
        credentials: 'same-origin',
        body: JSON.stringify({
          email: loginEmail,
          password: loginPassword,
        }),
      });
      const resp = await rawResponse.json();
      setLoginResponse(resp.Message);
      setRefreshToken(resp.RefreshToken);
    } catch (error) {
      alert(error.message);
    } finally {
      setLoading(false);
    }
  }

  async function logout(e: SyntheticEvent) {
    e.preventDefault();
    try {
      setLoading(true);
      const rawResponse = await fetch('/logout/', {
        method: 'GET',
        credentials: 'include',
      });
      const resp = await rawResponse.json();
      setLoginResponse(resp.Message);
    } catch (error) {
      alert(error.message);
    } finally {
      setLoading(false);
    }
  }

  async function signup(e: SyntheticEvent) {
    e.preventDefault();
    try {
      setLoading(true);
      const rawResponse = await fetch('/signup/', {
        method: 'POST',
        credentials: 'include',
        body: JSON.stringify({
          email: signupEmail,
          password: signupPassword,
        }),
      });
      const resp = await rawResponse.json();
      setSignupResponse(resp.Message);
    } catch (error) {
      alert(error.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div>
      <div className="center">
        <div className="container grid">
          <h1>Signup</h1>
          <div className="form-grid">
            <div className="field">
              <label htmlFor="email">Email</label>
              <input
                id="email"
                type="text"
                value={signupEmail}
                onChange={(e) => setSignupEmail(e.target.value)}
              />
            </div>
            <div className="field">
              <label htmlFor="password">Password</label>
              <input
                id="password"
                type="password"
                value={signupPassword}
                onChange={(e) => setSignupPassword(e.target.value)}
              />
            </div>
          </div>
          <button className="primary" onClick={signup}>
            {loading ? 'Loading... ' : 'Signup'}
            <div className={loading ? 'loader loading' : 'loader'}>ðŸš€</div>
          </button>
          {signupResponse && (
            <h2 className="response">
              {signupResponse} <div className="wave">ðŸ‘‹</div>
            </h2>
          )}
        </div>
      </div>

      <div className="center">
        <div className="container grid">
          <h1>Login</h1>
          <div className="form-grid">
            <div className="field">
              <label htmlFor="email">Email</label>
              <input
                id="email"
                type="text"
                value={loginEmail}
                onChange={(e) => setLoginEmail(e.target.value)}
              />
            </div>
            <div className="field">
              <label htmlFor="password">Password</label>
              <input
                id="password"
                type="password"
                value={loginPassword}
                onChange={(e) => setLoginPassword(e.target.value)}
              />
            </div>
          </div>
          <div className="form-grid">
            <button className="primary" onClick={login}>
              {loading ? 'Loading... ' : 'Login'}
              <div className={loading ? 'loader loading' : 'loader'}>ðŸš€</div>
            </button>
            <button className="primary" onClick={logout}>
              {loading ? 'Loading... ' : 'Logout'}
              <div className={loading ? 'loader loading' : 'loader'}>ðŸš€</div>
            </button>
          </div>

          {loginResponse && (
            <h2 className="response">
              {loginResponse} <div className="wave">ðŸ‘‹</div>
            </h2>
          )}
        </div>
      </div>
    </div>
  );
};

export default App;
```

## Run the service

Time to run our project, and see it in action!

```bash
nitric run
```

Take note of the entry point URL, ctrl+click the link or paste it in a browser to test it out.

```bash
âœ” Building Services
âœ” Creating docker network
âœ” Creating Volume: my-signup-app-vol-930352ad
âœ” Running Services
âœ” Starting API Gateways
âœ” Starting Entrypoints
 Service Port
 â”€â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€
 login   40415
 signup  36721
 Api        Port
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€
 onboarding 49155
 Entrypoint Url
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 main       http://localhost:33881
 Running, press 'Q' to clean up and exit...
```

Once you're happy that everything is running correctly, you can deploy your API application to a cloud provider of your choice.

```bash
# Deploy to AWS
nitric deploy:aws

# Deploy to Google Cloud
nitric deploy:gcp

# Deploy to Azure
nitric deploy:azure
```
