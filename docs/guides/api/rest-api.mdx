## What we'll do

1. Create a new Nitric stack
2. Create [functions](/docs/intro/concepts/functions) to handle API operations
3. Create a [documents](/docs/reference/api/documents) collection to store data
4. Set up an [API gateway](/reference/project/api-gateways) and bind it to the functions
5. Get it all running locally for testing
6. Deploy to a cloud of your choice

| **Method** | **Route**          | **Description**                |
| ---------- | ------------------ | ------------------------------ |
| `GET`      | /orders            | List all orders                |
| `GET`      | /orders/{$orderId} | Get a specific order by its ID |
| `POST`     | /orders            | Create a new order             |

> This tutorial provides examples in TypeScript, Python & Java.

## Getting started

This tutorial assumes you have the Nitric CLI installed, if not you can follow the [installation guide](/docs/getting-started/installation).

You'll also want to setup your environment to run and test Nitric applications locally by installing prerequisite software. Use the `nitric doctor` command to check and automatically setup your machine.

If you’d like to deploy the results to a cloud environment _(optional)_, you’ll also need to setup your credentials and any other cloud specific configuration: [AWS](/docs/intro/cloud-providers/aws), [GCP](/docs/intro/cloud-providers/gcp), or [Azure](/docs/intro/cloud-providers/azure).

## New stack

We’ll start by creating a new stack for the REST API.

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
	{
		label: "Java",
		value: "java"
	},
  {
		label: "Go",
		value: "go"
	}
	]}
	defaultLang="node"
><CodeExample lang="node">

<Box mt={4}>

You can create your Stack by running the `make:stack` command below:

</Box>

```bash
nitric make:stack rest-api
```

We love TypeScript, so let's choose `official/TypeScript Stack` as our template:

```text
? Stack template (Use arrow keys)
❯ official/TypeScript Stack
  official/Python Stack
  official/Java Stack
  official/Go Stack
```

Next, open the project in your editor of choice. The scaffolded project should have the following structure:

```text
rest-api
├── common
│   ├── example.ts
│   ├── index.ts
│   └── path.ts
├── functions
│   ├── create.ts
│   ├── list.ts
│   └── read.ts
├── .gitignore
├── api.yaml
├── nitric.yaml
├── package.json
└── yarn.lock
```

</CodeExample>
<CodeExample lang="python">

<Box mt={4}>

You can create your Stack by running the `make:stack` command below:

</Box>

```bash
nitric make:stack rest-api
```

We love Python, so let's choose `official/Python Stack` as our template:

```text
? Stack template (Use arrow keys)
  official/TypeScript Stack
❯ official/Python Stack
  official/Java Stack
  official/Go Stack
```

Next, open the project in your editor of choice. The scaffolded project should have the following structure:

```text
rest-api
├── common
│   ├── __init__.py
│   └── example.py
├── functions
│   ├── __init__.py
│   ├── create.py
│   ├── list.py
│   └── read.py
├── .gitignore
├── api.yaml
├── nitric.yaml
└── requirements.txt
```

</CodeExample>
<CodeExample lang="java">

<Box mt={4}>

You can create your Stack by running the `make:stack` command below:

</Box>

```bash
nitric make:stack rest-api
```

We love Java, so let's choose `official/Java Stack` as our template:

```text
? Stack template (Use arrow keys)
  official/TypeScript Stack
  official/Python Stack
❯ official/Java Stack
  official/Java Stack (Multi Module)
  official/Go Stack
```

> Note the `Java Stack (Multi Module)` option provides a multi module Maven project template. This template is more fully featured with unit tests and middleware, but is also more complex to get started with.

Next, open the project in your editor of choice. The scaffolded project should have the following structure:

```text
rest-api
├── src
│   └── main
│       └── java
│           ├── common
│           │   └── Example.java
│           └── function
│               ├── Create.java
│               ├── List.java
│               └── Read.java
├── .gitignore
├── api.yaml
├── nitric.yaml
└── pom.xml
```

</CodeExample>
<CodeExample lang="go">

<Box mt={4}>

You can create your Stack by running the `make:stack` command below:

</Box>

```bash
nitric make:stack rest-api
```

We love Go, so let's choose `official/Go Stack` as our template:

```text
? Stack template (Use arrow keys)
  official/TypeScript Stack
  official/Python Stack
  official/Java Stack
❯ official/Go Stack
```

Next, open the project in your editor of choice. The scaffolded project should have the following structure:

```text
rest-api
├── common
│   ├── json.go
│   └── params.go
├── functions
│   ├── create
│   │   └── main.go
│   ├── list
│   │   └── main.go
│   └── read
│       └── main.go
├── .gitignore
├── api.yaml
├── nitric.yaml
├── package.json
├── go.mod
└── go.sum
```

</CodeExample>
</CodeExamples>

The stack template already comes with a working API example, so we will use this example as a starter template for our orders API.

You can test the example stack with the `run` command.

```bash
nitric run
```

```bash
✔ Building Services
✔ Creating docker network
✔ Running Functions & Containers
✔ Starting API Gateways
✔ Starting Entrypoints
 Function Port
 ──────── ─────
 create   54054
 list     54055
 read     54056
 Api      Port
 ──────── ─────
 examples 49152
Running, press 'Q' to clean up and exit... -
```

Once running, use your browser to navigate to localhost on the port provided for the `examples` api, e.g. `http://localhost:49152/examples`. You should receive a success response from the api.

> The first time you run a stack it will take a moment longer to start while Docker image layers are downloaded and cached on your machine.

## Create orders

Next, let's turn the `create` function into the handler for `POST: /orders`, by having it add new orders to a document collection called `orders`. Since every new order will need a unique order id, for the purposes of this tutorial we'll generate a uuid to serve as the id.

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
	{
		label: "Java",
		value: "java"
	},
  {
		label: "Go",
		value: "go"
	}]}
	defaultLang="node"
>
<CodeExample lang="node">

<Box mt={4}>

The stack already comes with the `uuidv4` dependency for id generation, so let's install our dependencies from the root of the stack:

</Box>

```bash
yarn install
```

To improve our type safety, rename the `common/example.ts` file to be `common/order.ts` and replace its contents with our new `order` type:

```typescript
export interface Order {
  id: string;
  dateOrdered: string;
  itemId: string;
  customerId: string;
}
```

Ensure our Order interface is exported from `common/index.ts`:

```typescript
export * from './order';
export * from './path';
```

Next, update the `create.ts` function to receive an "order create request", create the order and store it in the `orders` collection.

```typescript
import { faas, documents } from '@nitric/sdk';
import { uuid } from 'uuidv4';
import { Order } from '../common';

// Requests to create a new order won't have an id or order date
type RequestData = Omit<Order, 'id' | 'dateOrdered'>;

interface CreateContext extends faas.HttpContext {
  req: faas.HttpRequest & {
    body?: RequestData;
  };
}

interface CreateResponse {
  message: string;
  orderId?: string;
}

// Start your function here
faas
  .http(
    faas.json(), //  use json body parser middleware to decode data
    async (ctx: CreateContext): Promise<faas.HttpContext> => {
      const data = ctx.req.body;
      const response = ctx.res;

      const order: Order = {
        ...data, // extract data from the request
        id: uuid(), // generate a new uuid
        dateOrdered: new Date().toJSON(),
      };

      const orders = documents().collection<Order>('orders');

      try {
        // Write the new order document to the orders collection
        await orders.doc(order.id).set(order);
        response.body = order.id;
        response.json({
          message: 'success',
          orderId: order.id,
        } as CreateResponse);
      } catch {
        response.status = 500;
        response.body = new TextEncoder().encode('failed to create order');
      }

      return ctx;
    }
  )
  .start();
```

</CodeExample>
<CodeExample lang="python">

<Box mt={4}>

Update the `create.py` function so that it receives OrderRequests, then creates a new order, stores it in the `orders` collection and returns the new order's id.
We can re-use the generate_id method from the example stack to generate our id.

</Box>

```python
# functions/create.py

import dataclasses
from datetime import datetime
from dataclasses import dataclass, field
from typing import Union

from nitric.faas import start, Trigger, Response
from nitric.api import Documents
from common.example import generate_id


@dataclass(frozen=True)
class OrderRequest:
  itemId: str
  customerId: str
  id: str = field(default_factory=lambda: str(generate_id()))
  dateOrdered: str = field(default_factory=lambda: str(datetime.now()))


async def handler(request: Trigger) -> Union[dict, Response]:
  order = OrderRequest(**request.get_object())

  orders = Documents().collection('orders')

  try:
    await orders.doc(order.id).set(dataclasses.asdict(order))
    return {"message": "success", "orderId": order.id}
  except:
    response = request.default_response()
    response.context.as_http().status = 500
    response.data = {"message": "failed to create order"}
    return response


if __name__ == "__main__":
  start(handler)

```

</CodeExample>
<CodeExample lang="java">

<Box mt={4}>

To improve our type safety, rename the `common/Example.java` file to be `common/Order.java` and replace its contents with our new `Order` type:

</Box>

```java
public class Order {
  public String id;
  public String dateOrdered;
  public String itemId;
  public String customerId;
}
```

Next, update the `Create.java` function to receive an "order create request", create the order and store it in the `orders` collection.

```java
package function;

import java.io.IOException;
import java.util.UUID;

import common.Order;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.nitric.api.document.Documents;
import io.nitric.faas.Faas;

public class Create {

    public static void main(String[] args) {
        new Faas()
            .http(context -> {
                try {
                    var json = context.getRequest().getDataAsText();
                    var order = new ObjectMapper().readValue(json, Order.class);
                    var id = UUID.randomUUID().toString();

                    new Documents().collection("orders").doc(id, Order.class).set(order);

                    context.getResponse()
                      .text("Created order with ID: %s", id);

                } catch (IOException ioe) {
                    context.getResponse()
                        .status(500)
                        .text("error: %s", ioe);
                }

                return context;
            })
            .start();
    }

}
```

</CodeExample>
<CodeExample lang="go">

<Box mt={4}>

The stack already comes with the `uuid` dependency for id generation, so let's install our dependencies from the root of the stack:

</Box>

```bash
go mod tidy -e
```

Next we'll define a common model to be used by our services for defining orders under `common/order.go` and add the following contents:

```go
package common

type Order struct {
	ID          string `json:"id"`
	DateOrdered string `json:"dateOrdered"`
	ItemID      string `json:"itemId"`
	CustomerID  string `json:"customerId"`
}
```

Next, update the `create/main.go` function to receive an "order create request", create the order and store it in the `orders` collection.

```go
// functions/create/main.go
package main

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/mitchellh/mapstructure"
	"github.com/nitrictech/go-sdk/api/documents"
	"github.com/nitrictech/go-sdk/faas"
	"nitric.io/rest-api/common"
)

// Updates context with error information
func httpError(ctx *faas.HttpContext, message string, status int) {
	ctx.Response.Body = []byte(message)
	ctx.Response.Status = status
}

func handler(ctx *faas.HttpContext, next faas.HttpHandler) (*faas.HttpContext, error) {
	order := &common.Order{}
	if err := json.Unmarshal(ctx.Request.Data(), order); err != nil {
		httpError(ctx, "error decoding json body", 400)
		return ctx, nil
	}

	// get the current time and set the order time
	orderTime := time.Now()
	order.DateOrdered = orderTime.Format(time.RFC3339)

	// set the ID of the order
	id := uuid.New().String()
	order.ID = id

	dc, _ := documents.New()

	// Convert the document to a map[string]interface{}
	// for storage, future iterations of the go-sdk may include direct interface{} storage as well
	orderMap := make(map[string]interface{})
	_ = mapstructure.Decode(order, &orderMap)

	if err := dc.Collection("orders").Doc(id).Set(orderMap); err != nil {
		httpError(ctx, "error writing orders document", 400)
		return ctx, nil
	}

	ctx.Response.Status = 200
	ctx.Response.Body = []byte(fmt.Sprintf("Created order with ID: %s", id))

	return next(ctx)
}

func main() {
	err := faas.New().Http(
		// Actual Handler
		handler,
	).Start()

	if err != nil {
		fmt.Println(err)
	}
}
```

</CodeExample>
</CodeExamples>

## Retrieve an order

Now that we can store new orders, let's update the read function for `GET: /orders/{$orderId}`, which will retrieve an order by its ID.

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
	{
		label: "Java",
		value: "java"
	},
  {
		label: "Go",
		value: "go"
	}
	]}
	defaultLang="node"
><CodeExample lang="node">

<Box mt={4}>

First, we want to parse the path so we can obtain the order id. We can do this by using a 3rd party package such as `path-parser`. This is already setup in our stack template under `common/path.ts`, we just need to update the code to match our orders api:

```typescript
// common/path.ts

import { Path } from 'path-parser';

export const path = new Path('/orders/:orderId');
```

Next, update the `read.ts` file for this function so that it gets the orderId from the URL path parameters and uses it to retrieve and return the order document.

</Box>

```typescript
// functions/read.ts

import { faas, documents } from '@nitric/sdk';
import { path } from '../common';

// Start your function here
faas
  .http(async (ctx: faas.HttpContext): Promise<faas.HttpContext> => {
    // get params from path
    const { orderId } = path.test(ctx.req.path);

    if (!orderId) {
      ctx.res.body = new TextEncoder().encode('Invalid Request');
      ctx.res.status = 400;
    }

    const orders = documents().collection('orders');

    try {
      const order = await orders.doc(orderId).get();
      ctx.res.json(order);
    } catch {
      ctx.res.status = 404;
      ctx.res.json({ message: 'order not found' });
    }

    return ctx;
  })
  .start();
```

</CodeExample>
<CodeExample lang="python">

<Box mt={4}>

First, update the `read.py` file for this function so that it gets the orderId from the URL path parameters and uses it to retrieve and return the order document.

</Box>

```python
# functions/read.py

from typing import Union

from nitric.api import Documents
from nitric.faas import start, Trigger, Response


async def handler(request: Trigger) -> Union[dict, Response]:
  order_id = request.context.as_http().path.split("/")[2]  # use a parser in a real project.

  orders = Documents().collection("orders")

  try:
    order = await orders.doc(order_id).get()

    return {
      "id": order.id,
      "order": order.content,
    }
  except:
    response = request.default_response()
    response.context.as_http().status = 404
    response.data = {"message": f"order with id: {order_id} not found"}
    return response


if __name__ == "__main__":
  start(handler)

```

</CodeExample>
<CodeExample lang="java">

<Box mt={4}>

First, update the `Read.java` file for this function so that it gets the orderId from the URL path parameters and uses it to retrieve and return the order document.

</Box>

```java
package function;

import com.fasterxml.jackson.databind.ObjectMapper;

import io.nitric.api.NotFoundException;
import io.nitric.api.document.Documents;
import io.nitric.faas.Faas;

import java.io.IOException;

public class Read {

    public static void main(String[] args) {
        new Faas()
            .http(context -> {
                var paths = context.getRequest().getPath().split("/");
                var id = paths[paths.length - 1];

                try {
                    var order = new Documents().collection("orders")
                        .doc(id)
                        .get();

                    var json = new ObjectMapper().writeValueAsString(order);

                    context.getResponse()
                        .contentType("application/json")
                        .text(json);

                } catch (NotFoundException nfe) {
                    context.getResponse()
                        .status(404)
                        .text("Document not found: %s", id);

                } catch (IOException ioe) {
                    context.getResponse()
                        .status(500)
                        .text("Error getting order: %s", ioe);
                }

                return context;
            })
            .start();
    }
}
```

</CodeExample>
<CodeExample lang="go">

<Box mt={4}>

First, we want to parse the path so we can obtain the order id. We could use a third party library to achieve this.
A parser is already setup in our stack template under `common/params.go`, we just need to update the code to match our orders api.

</Box>

```go
// functions/read/main.go
package main

import (
	"encoding/json"
	"fmt"

	"github.com/nitrictech/go-sdk/api/documents"
	"github.com/nitrictech/go-sdk/faas"
	"nitric.io/rest-api/common"
)

func handler(ctx *faas.HttpContext, next faas.HttpHandler) (*faas.HttpContext, error) {
	params, ok := ctx.Extras["params"].(map[string]string)

	if !ok || params == nil {
		return nil, fmt.Errorf("error retrieving path params")
	}

	id := params["id"]

	dc, err := documents.New()
	if err != nil {
		return nil, err
	}

	doc, err := dc.Collection("orders").Doc(id).Get()
	if err != nil {
		ctx.Response.Body = []byte("Error retrieving document")
		ctx.Response.Status = 404
	} else {
		b, err := json.Marshal(doc.Content())
		if err != nil {
			return nil, err
		}

		ctx.Response.Headers["Content-Type"] = []string{"application/json"}
		ctx.Response.Body = b
	}

	return next(ctx)
}

func main() {
	err := faas.New().Http(
		// Retrieve path parameters if available
		common.PathParser("/orders/:id"),
		// Actual Handler
		handler,
	).Start()

	if err != nil {
		fmt.Println(err)
	}
}
```

</CodeExample>
</CodeExamples>

## List all orders

Finally, we'll update the list function for `GET: /orders`, which will list every order.

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
	{
		label: "Java",
		value: "java"
	},
  {
		label: "Go",
		value: "go"
	}
	]}
	defaultLang="node"
>
<CodeExample lang="node">

<Box mt={4}>

Update the `list.ts` file for the list function so it retrieves every order from the `orders` collection.

</Box>

```typescript
// functions/list.ts

import { faas, documents } from '@nitric/sdk';
import { Order } from '../common';

interface Result {
  id: string;
  content: Order;
}

faas
  .http(async (ctx: faas.HttpContext): Promise<faas.HttpContext> => {
    const orders = documents().collection<Order>('orders');
    const results: Result[] = [];
    let token: any = null;
    while (true) {
      try {
        const page = await orders.query().pagingFrom(token).fetch();

        results.push(
          ...page.documents.map(({ id, content }) => ({
            id,
            content,
          }))
        );

        if (!page.pagingToken) {
          break;
        }

        token = page.pagingToken;
      } catch (e) {
        ctx.res.status = 500;
        return ctx.res.json({ message: e.stack });
      }
    }
    return ctx.res.json(results);
  })
  .start();
```

</CodeExample>
<CodeExample lang="python">

<Box mt={4}>

Update the `list.py` file for the list function so it retrieves every order from the `orders` collection.

</Box>

```python
# functions/list.py

from nitric.api import Documents
from nitric.faas import start, Trigger, Response


async def handler(request: Trigger) -> list:
  orders = Documents().collection("orders")
  results = []
  token = None

  while True:
    page = await orders.query().page_from(token).fetch()
    results += [{"content": doc.content, "id": doc.id} for doc in page.documents]
    token = page.paging_token
    if not token:
        break
  return results


if __name__ == "__main__":
  start(handler)
```

</CodeExample>
<CodeExample lang="java">

<Box mt={4}>

Update the `List.java` file for the list function so it retrieves every order from the `orders` collection.

</Box>

```java
package function;

import common.Order;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.nitric.api.document.Documents;
import io.nitric.api.document.ResultDoc;
import io.nitric.faas.Faas;

import java.io.IOException;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class List {

    public static void main(String[] args) {
        new Faas()
            .http(context -> {
                Stream<ResultDoc<Order>> stream = new Documents().collection("orders")
                    .query(Order.class)
                    .stream();

                java.util.List<Order> orders = stream
                    .map(ResultDoc::getContent)
                    .collect(Collectors.toUnmodifiableList());

                try {
                    var json = new ObjectMapper().writeValueAsString(orders);

                    context.getResponse()
                        .contentType("application/json")
                        .text(json);

                } catch (IOException ioe) {
                    context.getResponse()
                        .status(500)
                        .text("Error querying orders: %s", ioe);
                }

                return context;
            })
            .start();
    }

}
```

</CodeExample>
<CodeExample lang="go">

<Box mt={4}>

Update the `list/main.go` file for the list function so it retrieves every order from the `orders` collection.

</Box>

```go
// functions/list/main.go
package main

import (
	"encoding/json"
	"fmt"

	"github.com/nitrictech/go-sdk/api/documents"
	"github.com/nitrictech/go-sdk/faas"
)

func handler(ctx *faas.HttpContext, next faas.HttpHandler) (*faas.HttpContext, error) {
	dc, err := documents.New()
	if err != nil {
		return nil, err
	}

	query := dc.Collection("orders").Query()
	results, err := query.Fetch()

	if err != nil {
		return nil, err
	}

	docs := make([]map[string]interface{}, 0)

	for _, doc := range results.Documents {
		// handle documents
		docs = append(docs, doc.Content())
	}

	b, err := json.Marshal(docs)
	if err != nil {
		return nil, err
	}

	ctx.Response.Body = b
	ctx.Response.Headers["Content-Type"] = []string{"application/json"}

	return next(ctx)
}

func main() {
	err := faas.New().Http(
		// Actual Handler
		handler,
	).Start()

	if err != nil {
		fmt.Println(err)
	}
}
```

</CodeExample>
</CodeExamples>

## Add the API Gateway

Now that we have functions to handle our API operations, we can add the API definition to our project. This will make the functions accessible and trigger them in response to specific requests to the API URL.

> Learn more: [API Gateways Documentation](/docs/reference/project/api-gateways)

Update your `api.yaml` file to the following:

```yaml
# Note: APIs are defined in OpenAPI Spec 3. The following is a basic example, but can be extended using the specification standards.
openapi: 3.0.0
info:
  version: 1.0.0
  title: Orders API
  description: Tutorial orders API
paths:
  /orders:
    get:
      operationId: list
      x-nitric-target:
        name: list
        type: function
      description: Retrieve all orders
      responses:
        '200':
          description: Successful response
    post:
      operationId: create
      x-nitric-target:
        name: create
        type: function
      description: Creates and persists new orders
      responses:
        '200':
          description: Successful response
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OrderCreate'
  /orders/{orderId}:
    get:
      operationId: read
      parameters:
        - in: path
          name: orderId
          schema:
            type: string
          required: true
      x-nitric-target:
        name: read
        type: function
      description: Retrieve an existing order by its ID
      responses:
        '200':
          description: Successful response
components:
  schemas:
    OrderCreate:
      type: object
      properties:
        itemId:
          type: string
        customerId:
          type: string
```

Now lets add our `orders` collection and rename our API, update your `nitric.yaml` to the following:

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
	{
		label: "Java",
		value: "java"
	},
  {
		label: "Go",
		value: "go"
	}
	]}
	defaultLang="node"
>
<CodeExample lang="node">

```yaml
name: rest-api
# Nitric functions
functions:
  create:
    handler: functions/create.ts
  read:
    handler: functions/read.ts
  list:
    handler: functions/list.ts
# Nitric collections
collections:
  orders: {}
# Nitric APIs
apis:
  orders: api.yaml
```

</CodeExample>
<CodeExample lang="python">

```yaml
name: rest-api
# Nitric functions
functions:
  create:
    handler: functions/create.py
  read:
    handler: functions/read.py
  list:
    handler: functions/list.py
# Nitric collections
collections:
  orders: {}
# Nitric APIs
apis:
  orders: api.yaml
```

</CodeExample>
<CodeExample lang="java">

```yaml
name: rest-api
# Nitric functions
functions:
  create:
    handler: target/create.jar
  list:
    handler: target/list.jar
  read:
    handler: target/read.jar
# Nitric collections
collections:
  orders: {}
# Nitric APIs
apis:
  orders: api.yaml
```

</CodeExample>
<CodeExample lang="go">

```yaml
name: rest-api
# Nitric functions
functions:
  create:
    handler: functions/create/main.go
  read:
    handler: functions/read/main.go
  list:
    handler: functions/list/main.go
# Nitric collections
collections:
  orders: {}
# Nitric APIs
apis:
  orders: api.yaml
```

</CodeExample>
</CodeExamples>

## Run it!

Now that you have an API defined and functions built to handle each of its methods, it's time to test it out locally before deploying to the cloud.

Try out your application with the `run` command:

```bash
nitric run
```

> _Note:_ In this case, `run` starts a container to act as an API gateway, as well as a container for each of the services.

Once it starts, the application will receive requests via the API port. You can use cURL, Postman or any other HTTP client to test the API.

Replace the **49152** PORT below with your PORT (if applicable):

#### Create an order

```bash
curl -H "Content-Type: application/json" -X POST -d '{"itemId":"test-item","customerId": "test-customer"}' http://localhost:49152/orders
```

#### Retrieve an order

```bash
curl http://localhost:49152/orders/YOUR_ORDER_ID
```

#### List orders

```bash
curl http://localhost:49152/orders
```

## Deploy to the cloud

Once you're happy that everything is running correctly, you can deploy your API application to a cloud provider of your choice.

<Box
  sx={{
    mb: 2,
    px: 2,
    borderRadius: '4px',
    display: 'grid',
    gap: {
      md: 3,
    },
    gridTemplateColumns: 'repeat(3, 1fr)',
    backgroundColor: '#f4f4f4',
    '& > a': {
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'center',
      px: 1,
      my: {
        xs: 1,
        md: 2,
      },
      transition: 'all 0.3s ease-in',
      '&:hover, &:focus': {
        backgroundColor: '#ececec',
      },
    },
  }}
>
  <Link href="/docs/intro/cloud-providers/aws">
    <img src="/img/logos/aws.svg" noMargin priority height={50} />
  </Link>
  <Link href="/docs/intro/cloud-providers/gcp">
    <img src="/img/logos/gcp.svg" noMargin priority height={130} />
  </Link>
  <Link href="/docs/intro/cloud-providers/azure">
    <img src="/img/logos/azure.svg" noMargin priority height={40} />
  </Link>
</Box>

## Next Steps

Time to validate user permissions and protect our API endpoints, [secure your API with Auth0](/docs/guides/api/rest-api-auth0).

## Reference

The completed application code for this guide can downloaded via the command line:

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
  {
		label: "Java",
		value: "java"
	}
	]}
	defaultLang="node"
>
<CodeExample lang="node">

```bash
 curl https://codeload.github.com/nitrictech/nitric-examples/tar.gz/main | tar -xz --strip=2 nitric-examples-main/typescript/rest-api
```

</CodeExample>
<CodeExample lang="python">

Python reference coming soon!

</CodeExample>
<CodeExample lang="java">

```bash
 curl https://codeload.github.com/nitrictech/nitric-examples/tar.gz/main | tar -xz --strip=2 nitric-examples-main/java/rest-api
```

</CodeExample>
</CodeExamples>

> If you're having issues extracting the tar, use Git Bash to execute the command
